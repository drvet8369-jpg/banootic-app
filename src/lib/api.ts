// This file will be our Data Access Layer.
// All functions that interact with Supabase will live here.
// The UI components will call these functions instead of directly
// interacting with Supabase. This makes the code cleaner, more testable,
// and easier to maintain or switch data sources in the future.

import { createClient } from '@supabase/supabase-js';
import type { Provider, Review, Agreement } from './types';
import { defaultProviders } from './data'; // We need this for seeding

// These values are loaded from the .env file.
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

// More robust check for environment variables to prevent runtime errors.
if (!supabaseUrl || supabaseUrl.includes('YOUR_SUPABASE_URL_HERE') || !supabaseUrl.startsWith('http')) {
  throw new Error("Supabase URL is not configured correctly in the .env file. Please make sure NEXT_PUBLIC_SUPABASE_URL is a valid URL.");
}
if (!supabaseAnonKey || supabaseAnonKey.includes('YOUR_SUPABASE_ANON_KEY_HERE')) {
    throw new Error("Supabase Anon Key is not configured correctly in the .env file. Please check NEXT_PUBLIC_SUPABASE_ANON_KEY.");
}


// Initialize the Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey);


/**
 * Seeds the initial provider data from the local `data.ts` file into the Supabase table.
 * This is intended to be a one-time operation.
 * @returns {Promise<Provider[]>} The list of providers that were inserted.
 */
async function seedInitialProviders(): Promise<Provider[]> {
    console.log("Seeding initial provider data to Supabase...");
    
    // We need to map our local data to match the Supabase table schema
    const dataToInsert = defaultProviders.map(p => ({
        // We don't insert 'id' because it's auto-generated by the database
        name: p.name,
        service: p.service,
        location: p.location,
        phone: p.phone,
        bio: p.bio,
        category_slug: p.categorySlug,
        service_slug: p.serviceSlug,
        rating: p.rating,
        reviews_count: p.reviewsCount,
        profile_image: p.profileImage,
        portfolio: p.portfolio,
    }));

    const { data, error } = await supabase
        .from('providers')
        .insert(dataToInsert)
        .select();

    if (error) {
        console.error("Error seeding providers:", error);
        throw new Error("Could not seed initial provider data.");
    }
    
    console.log("Seeding successful!");
     const providers = data.map(p => ({
      id: p.id,
      name: p.name,
      service: p.service,
      location: p.location,
      phone: p.phone,
      bio: p.bio,
      categorySlug: p.category_slug,
      serviceSlug: p.service_slug,
      rating: p.rating,
      reviewsCount: p.reviews_count,
      profileImage: p.profile_image,
      portfolio: p.portfolio,
  }));
    return providers;
}


/**
 * Fetches all service providers.
 * If the providers table is empty, it seeds the initial data first.
 * @returns {Promise<Provider[]>} A list of all providers.
 */
export async function getAllProviders(): Promise<Provider[]> {
  console.log("API: Fetching all providers from Supabase...");

  // First, check if there are any providers in the table
  let { count } = await supabase
    .from('providers')
    .select('id', { count: 'exact', head: true });

  // If the table is empty, seed it with initial data
  if (count === 0) {
      console.log("No providers found. Seeding initial data...");
      return await seedInitialProviders();
  }

  // If providers exist, fetch all of them
  const { data, error } = await supabase
    .from('providers')
    .select('*');

  if (error) {
    console.error("Error fetching providers:", error);
    throw new Error("Could not fetch providers.");
  }

  // The data from supabase will have snake_case keys, we need to convert them to camelCase
  // to match our Provider type.
  const providers = data.map(p => ({
      id: p.id,
      name: p.name,
      service: p.service,
      location: p.location,
      phone: p.phone,
      bio: p.bio,
      categorySlug: p.category_slug,
      serviceSlug: p.service_slug,
      rating: p.rating,
      reviewsCount: p.reviews_count,
      profileImage: p.profile_image,
      portfolio: p.portfolio,
  }));
  
  return providers;
}
