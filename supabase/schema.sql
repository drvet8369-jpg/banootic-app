
-- Enable the "http" extension
create extension if not exists "http" with schema "extensions";

-- Enable PostGIS for geographic queries if needed
-- create extension if not exists postgis with schema "extensions";

-- Set up tables

-- Table for one-time passwords used in authentication
create table if not exists public.one_time_passwords (
  id bigint generated by default as identity primary key,
  phone text not null unique,
  token text not null,
  created_at timestamp with time zone not null default now()
);
alter table public.one_time_passwords enable row level security;

-- Table for user profiles, linked to Supabase's auth.users
create table if not exists public.profiles (
  id uuid not null primary key references auth.users (id) on delete cascade,
  updated_at timestamp with time zone,
  full_name text,
  phone text unique,
  account_type text default 'customer'::text
);
alter table public.profiles enable row level security;

-- Table for service providers, linked to profiles
create table if not exists public.providers (
  id bigint generated by default as identity primary key,
  profile_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  service text not null,
  location text,
  phone text not null unique,
  bio text,
  category_slug text,
  service_slug text,
  rating numeric(2,1) default 0.0,
  reviews_count integer default 0,
  profile_image jsonb
);
alter table public.providers enable row level security;

-- Table for portfolio items, linked to providers
create table if not exists public.portfolio_items (
  id bigint generated by default as identity primary key,
  provider_id bigint not null references public.providers(id) on delete cascade,
  image_url text not null,
  ai_hint text
);
alter table public.portfolio_items enable row level security;

-- Table for reviews, linked to providers and profiles
create table if not exists public.reviews (
  id bigint generated by default as identity primary key,
  provider_id bigint not null references public.providers(id) on delete cascade,
  author_id uuid not null references public.profiles(id) on delete cascade,
  author_name text not null,
  rating integer not null check (rating >= 1 and rating <= 5),
  comment text,
  created_at timestamp with time zone not null default now()
);
alter table public.reviews enable row level security;


-- Set up Row Level Security (RLS) policies

-- Grant all permissions to the service_role (trusted server-side code)
-- This is crucial for server actions and admin tasks to bypass RLS.
drop policy if exists "Allow all for service_role" on public.one_time_passwords;
create policy "Allow all for service_role" on public.one_time_passwords for all using (true) with check (true);

drop policy if exists "Allow all for service_role" on public.profiles;
create policy "Allow all for service_role" on public.profiles for all using (true) with check (true);

drop policy if exists "Allow all for service_role" on public.providers;
create policy "Allow all for service_role" on public.providers for all using (true) with check (true);

drop policy if exists "Allow all for service_role" on public.portfolio_items;
create policy "Allow all for service_role" on public.portfolio_items for all using (true) with check (true);

drop policy if exists "Allow all for service_role" on public.reviews;
create policy "Allow all for service_role" on public.reviews for all using (true) with check (true);


-- Policies for 'one_time_passwords'
drop policy if exists "Allow read access to authenticated users" on public.one_time_passwords;
create policy "Allow read access to authenticated users" on public.one_time_passwords for select using (auth.role() = 'authenticated');

-- Policies for 'profiles'
drop policy if exists "Enable read access for all users" on public.profiles;
create policy "Enable read access for all users" on public.profiles for select using (true);

drop policy if exists "Enable update for users based on user_id" on public.profiles;
create policy "Enable update for users based on user_id" on public.profiles for update using (auth.uid() = id) with check (auth.uid() = id);

-- Policies for 'providers'
drop policy if exists "Enable read access for all users" on public.providers;
create policy "Enable read access for all users" on public.providers for select using (true);

drop policy if exists "Enable insert for authenticated users" on public.providers;
create policy "Enable insert for authenticated users" on public.providers for insert with check (auth.role() = 'authenticated');

drop policy if exists "Enable update for provider's own profile" on public.providers;
create policy "Enable update for provider's own profile" on public.providers for update using (auth.uid() = profile_id) with check (auth.uid() = profile_id);

-- Policies for 'portfolio_items'
drop policy if exists "Enable read access for all users" on public.portfolio_items;
create policy "Enable read access for all users" on public.portfolio_items for select using (true);

drop policy if exists "Enable insert for provider's own portfolio" on public.portfolio_items;
create policy "Enable insert for provider's own portfolio" on public.portfolio_items for insert with check (
  auth.uid() = (select profile_id from public.providers where id = provider_id)
);

drop policy if exists "Enable delete for provider's own portfolio" on public.portfolio_items;
create policy "Enable delete for provider's own portfolio" on public.portfolio_items for delete using (
  auth.uid() = (select profile_id from public.providers where id = provider_id)
);

-- Policies for 'reviews'
drop policy if exists "Enable read access for all users" on public.reviews;
create policy "Enable read access for all users" on public.reviews for select using (true);

drop policy if exists "Enable insert for authenticated users" on public.reviews;
create policy "Enable insert for authenticated users" on public.reviews for insert with check (auth.uid() = author_id);


-- This trigger automatically creates a profile entry when a new user signs up.
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, phone, full_name, account_type)
  values (new.id, new.phone, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'account_type');
  return new;
end;
$$;

-- Drop the trigger if it exists to avoid errors on re-run
drop trigger if exists on_auth_user_created on auth.users;

-- Create the trigger
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- Function to recalculate average rating for a provider
create or replace function public.recalculate_provider_rating(p_provider_id bigint)
returns void
language plpgsql
security definer set search_path = public
as $$
declare
  new_avg numeric;
  new_count int;
begin
  select
    avg(rating),
    count(id)
  into
    new_avg,
    new_count
  from public.reviews
  where provider_id = p_provider_id;

  update public.providers
  set
    rating = coalesce(new_avg, 0),
    reviews_count = coalesce(new_count, 0)
  where id = p_provider_id;
end;
$$;

-- Trigger to update rating after a new review is inserted or updated
create or replace function public.handle_new_review()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  perform public.recalculate_provider_rating(new.provider_id);
  return new;
end;
$$;

drop trigger if exists on_review_change on public.reviews;
create trigger on_review_change
  after insert or update of rating on public.reviews
  for each row execute procedure public.handle_new_review();

-- Trigger to update rating after a review is deleted
create or replace function public.handle_deleted_review()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  perform public.recalculate_provider_rating(old.provider_id);
  return old;
end;
$$;

drop trigger if exists on_review_deleted on public.reviews;
create trigger on_review_deleted
  after delete on public.reviews
  for each row execute procedure public.handle_deleted_review();
