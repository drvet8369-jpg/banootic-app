-- Honarbanoo DB Schema
-- Version 1.0

-- 1. Extensions
-- No new extensions needed for this schema.

-- 2. Create Tables

-- Table for service categories (e.g., Beauty, Cooking)
CREATE TABLE IF NOT EXISTS public.categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  description TEXT
);
COMMENT ON TABLE public.categories IS 'Stores the main categories of services offered.';

-- Table for specific services within a category (e.g., Manicure, Haircut)
CREATE TABLE IF NOT EXISTS public.services (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category_id BIGINT NOT NULL REFERENCES public.categories(id),
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE
);
COMMENT ON TABLE public.services IS 'Stores specific services offered within each category.';


-- Table for user profiles, linked to Supabase's auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  phone TEXT UNIQUE,
  account_type TEXT NOT NULL DEFAULT 'customer', -- 'customer' or 'provider'
  bio TEXT,
  location TEXT,
  profile_image_url TEXT,
  service_id BIGINT REFERENCES public.services(id),
  rating NUMERIC(2, 1) DEFAULT 0.0,
  reviews_count INT DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.profiles IS 'Stores public profile information for all users (customers and providers).';

-- Table for reviews given by customers to providers
CREATE TABLE IF NOT EXISTS public.reviews (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  provider_id UUID NOT NULL REFERENCES public.profiles(id),
  author_id UUID NOT NULL REFERENCES public.profiles(id),
  rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.reviews IS 'Stores reviews and ratings for providers.';


-- Table for one-time passwords used for phone authentication
CREATE TABLE IF NOT EXISTS public.one_time_passwords (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  phone TEXT NOT NULL UNIQUE,
  token TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.one_time_passwords IS 'Stores OTPs for phone verification.';


-- 3. Insert Initial Data (Seed Data)

-- Seed Categories
INSERT INTO public.categories(name, slug, description)
VALUES
  ('خدمات زیبایی بانوان', 'beauty', 'خدمات مو، ناخن، آرایش و مراقبت از پوست توسط متخصصان محلی با استعداد.'),
  ('آشپزی و غذای خانگی', 'cooking', 'غذاهای خانگی خوشمزه و اصیل، شیرینی‌جات و غذاهای سنتی.'),
  ('خیاطی و طراحی مد', 'tailoring', 'لباس‌های سفارشی، تعمیرات و طراحی‌های مد منحصر به فرد از بوتیک‌های محلی.'),
  ('صنایع دستی و تزئینی', 'handicrafts', 'کاردستی‌های دکوری، هنرهای تزئینی و محصولات دست‌ساز منحصر به فرد.');

-- Seed Services
INSERT INTO public.services(name, slug, category_id)
VALUES
  ('خدمات ناخن', 'manicure-pedicure', 1),
  ('خدمات مو', 'haircut-coloring', 1),
  ('پاکسازی پوست', 'facial-treatment', 1),
  ('آرایش صورت', 'makeup', 1),
  ('اپیلاسیون', 'waxing', 1),
  ('غذای سنتی', 'traditional-food', 2),
  ('کیک و شیرینی', 'cakes-sweets', 2),
  ('غذای گیاهی', 'vegetarian-vegan', 2),
  ('فینگرفود', 'finger-food', 2),
  ('نان خانگی', 'homemade-bread', 2),
  ('دوخت سفارشی لباس', 'custom-clothing', 3),
  ('مزون، لباس عروس و مجلسی', 'fashion-design-mezon', 3),
  ('تعمیرات تخصصی لباس', 'clothing-repair', 3),
  ('زیورآلات دست‌ساز', 'handmade-jewelry', 4),
  ('سفال تزئینی', 'decorative-pottery', 4),
  ('بافتنی‌ها', 'termeh-kilim', 4),
  ('چرم‌دوزی', 'leather-crafts', 4),
  ('شمع‌سازی', 'candles-soaps', 4);


-- 4. Set up Row Level Security (RLS)

ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.one_time_passwords ENABLE ROW LEVEL SECURITY;

-- Policies for categories: Everyone can read.
CREATE POLICY "Allow public read access to categories" ON public.categories FOR SELECT USING (true);

-- Policies for services: Everyone can read.
CREATE POLICY "Allow public read access to services" ON public.services FOR SELECT USING (true);

-- Policies for profiles:
CREATE POLICY "Allow public read access to profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Allow users to insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow users to update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Policies for reviews:
CREATE POLICY "Allow public read access to reviews" ON public.reviews FOR SELECT USING (true);
CREATE POLICY "Allow authenticated users to insert reviews" ON public.reviews FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Allow users to delete their own reviews" ON public.reviews FOR DELETE USING (auth.uid() = author_id);

-- Policies for OTPs: These should be handled by service_role key on the server, so no RLS needed for client access.

-- 5. Create Functions & Triggers

-- Function to automatically create a profile when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, phone, full_name, account_type)
  VALUES (
    NEW.id,
    NEW.phone,
    NEW.raw_user_meta_data ->> 'full_name',
    NEW.raw_user_meta_data ->> 'account_type'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function on new user creation
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- Function to search providers
CREATE OR REPLACE FUNCTION public.search_providers(search_term TEXT)
RETURNS TABLE (
  id UUID,
  full_name TEXT,
  phone TEXT,
  bio TEXT,
  location TEXT,
  profile_image_url TEXT,
  rating NUMERIC,
  reviews_count INT,
  service_name TEXT,
  category_slug TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.full_name,
    p.phone,
    p.bio,
    p.location,
    p.profile_image_url,
    p.rating,
    p.reviews_count,
    s.name AS service_name,
    c.slug AS category_slug
  FROM
    public.profiles p
    JOIN public.services s ON p.service_id = s.id
    JOIN public.categories c ON s.category_id = c.id
  WHERE
    p.account_type = 'provider' AND
    (
      p.full_name ILIKE '%' || search_term || '%' OR
      p.bio ILIKE '%' || search_term || '%' OR
      s.name ILIKE '%' || search_term || '%' OR
      c.name ILIKE '%' || search_term || '%'
    );
END;
$$ LANGUAGE plpgsql;

-- 6. Indexes for performance
CREATE INDEX IF NOT EXISTS idx_profiles_account_type ON public.profiles(account_type);
CREATE INDEX IF NOT EXISTS idx_services_category_id ON public.services(category_id);
CREATE INDEX IF NOT EXISTS idx_reviews_provider_id ON public.reviews(provider_id);


-- Schema setup finished.
