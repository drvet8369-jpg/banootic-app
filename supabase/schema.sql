-- ### SETUP: EXTENSIONS & SCHEMA ###

-- Enable the "citext" extension for case-insensitive text.
-- This is useful for emails, usernames, etc. to prevent duplicates like "user@example.com" and "User@example.com".
CREATE EXTENSION IF NOT EXISTS "citext" WITH SCHEMA "public";

-- Enable the "pg_stat_statements" extension for monitoring query performance.
-- This helps in debugging and optimizing database queries.
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";

-- Enable the "pgcrypto" extension for cryptographic functions.
-- This is essential for generating UUIDs and other security-related operations.
CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";

-- ### TABLE: users ###
-- This table stores public profile information for all users (both customers and providers).
-- It is linked to the private `auth.users` table via the `id` field (UUID).
DROP TABLE IF EXISTS "public"."users";
CREATE TABLE "public"."users" (
    "id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "phone" "text" NOT NULL,
    "account_type" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- Add comments for clarity on the `users` table and its columns.
COMMENT ON TABLE "public"."users" IS 'Stores public profile data for all users, linked to auth.users.';
COMMENT ON COLUMN "public"."users"."id" IS 'Links to auth.users.id';

-- Set up the primary key for the `users` table.
ALTER TABLE "public"."users" ADD CONSTRAINT "users_pkey" PRIMARY KEY USING INDEX ON "users" ("id");

-- Add foreign key constraint to link `users.id` to `auth.users.id`.
-- This ensures that every user profile corresponds to an actual authenticated user.
-- The `ondelete cascade` ensures that if a user is deleted from `auth.users`, their public profile is also deleted.
ALTER TABLE "public"."users" ADD CONSTRAINT "users_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;


-- ### TABLE: providers ###
-- This table stores specific information for users who are service providers.
DROP TABLE IF EXISTS "public"."providers";
CREATE TABLE "public"."providers" (
    "id" "bigint" GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "phone" "text" NOT NULL,
    "service" "text" NOT NULL,
    "location" "text" NOT NULL,
    "bio" "text" NOT NULL,
    "category_slug" "text" NOT NULL,
    "service_slug" "text" NOT NULL,
    "rating" real DEFAULT '0'::real NOT NULL,
    "reviews_count" integer DEFAULT 0 NOT NULL,
    "profile_image" "jsonb" NOT NULL,
    "portfolio" "jsonb"[] DEFAULT '{}'::"jsonb"[] NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- Add comments for the `providers` table.
COMMENT ON TABLE "public"."providers" IS 'Stores detailed profiles for service providers.';

-- Set up the primary key for the `providers` table using the auto-incrementing `id`.
ALTER TABLE "public"."providers" ADD CONSTRAINT "providers_pkey" PRIMARY KEY USING INDEX ON "providers" ("id");

-- Add foreign key constraint to link `providers.user_id` to `users.id`.
-- This ensures that every provider profile is linked to a valid user profile.
ALTER TABLE "public"."providers" ADD CONSTRAINT "providers_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;


-- ### TABLE: customers ###
-- This table is currently a placeholder. It could be used to store customer-specific
-- information in the future, like preferences or shipping addresses.
DROP TABLE IF EXISTS "public"."customers";
CREATE TABLE "public"."customers" (
    "id" "bigint" GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "user_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- Add comments for the `customers` table.
COMMENT ON TABLE "public"."customers" IS 'Stores data specific to customers.';

-- Set up the primary key for the `customers` table.
ALTER TABLE "public"."customers" ADD CONSTRAINT "customers_pkey" PRIMARY KEY USING INDEX ON "customers" ("id");

-- Add foreign key constraint to link `customers.user_id` to `users.id`.
ALTER TABLE "public"."customers" ADD CONSTRAINT "customers_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;


-- ### TABLE: reviews ###
-- This table stores reviews and ratings given by customers to providers.
DROP TABLE IF EXISTS "public"."reviews";
CREATE TABLE "public"."reviews" (
    "id" "bigint" GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "provider_id" "bigint" NOT NULL,
    "customer_id" "uuid" NOT NULL,
    "rating" "integer" NOT NULL,
    "comment" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "customer_name" "text" NOT NULL
);

-- Add comments for the `reviews` table.
COMMENT ON TABLE "public"."reviews" IS 'Stores customer reviews for providers.';

-- Set up the primary key for the `reviews` table.
ALTER TABLE "public"."reviews" ADD CONSTRAINT "reviews_pkey" PRIMARY KEY USING INDEX ON "reviews" ("id");

-- Add foreign key constraint linking `reviews.customer_id` to `users.id`.
ALTER TABLE "public"."reviews" ADD CONSTRAINT "reviews_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

-- Add foreign key constraint linking `reviews.provider_id` to `providers.id`.
ALTER TABLE "public"."reviews" ADD CONSTRAINT "reviews_provider_id_fkey" FOREIGN KEY ("provider_id") REFERENCES "public"."providers"("id") ON DELETE CASCADE;

-- Add a check constraint to ensure the rating is between 1 and 5.
ALTER TABLE "public"."reviews" ADD CONSTRAINT "reviews_rating_check" CHECK (("rating" >= 1) AND ("rating" <= 5));


-- ### TABLE: agreements ###
-- This table tracks service agreements between customers and providers.
DROP TABLE IF EXISTS "public"."agreements";
CREATE TABLE "public"."agreements" (
    "id" "bigint" GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "customer_phone" "text" NOT NULL,
    "provider_phone" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "requested_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "confirmed_at" timestamp with time zone
);

-- Add comments for the `agreements` table.
COMMENT ON TABLE "public"."agreements" IS 'Tracks service agreements between customers and providers.';

-- Set up the primary key for the `agreements` table.
ALTER TABLE "public"."agreements" ADD CONSTRAINT "agreements_pkey" PRIMARY KEY USING INDEX ON "agreements" ("id");


-- ### TABLE: conversations ###
-- This table stores information about a chat conversation between two users.
DROP TABLE IF EXISTS "public"."conversations";
CREATE TABLE "public"."conversations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "participant_one_id" "uuid" NOT NULL,
    "participant_two_id" "uuid" NOT NULL,
    "last_message_at" timestamp with time zone
);

-- Add comments for the `conversations` table.
COMMENT ON TABLE "public"."conversations" IS 'Represents a chat conversation between two users.';

-- Set up the primary key for the `conversations` table.
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_pkey" PRIMARY KEY USING INDEX ON "conversations" ("id");

-- Add foreign key constraints to link participants to the `users` table.
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_participant_one_id_fkey" FOREIGN KEY ("participant_one_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_participant_two_id_fkey" FOREIGN KEY ("participant_two_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

-- Add a unique constraint to prevent duplicate conversations between the same two users.
-- The `LEAST` and `GREATEST` functions ensure the order of participants doesn't matter.
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_unique_participants" UNIQUE ("participant_one_id", "participant_two_id");


-- ### TABLE: messages ###
-- This table stores individual chat messages within a conversation.
DROP TABLE IF EXISTS "public"."messages";
CREATE TABLE "public"."messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "conversation_id" "uuid" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "receiver_id" "uuid" NOT NULL,
    "content" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "is_read" boolean DEFAULT false NOT NULL
);

-- Add comments for the `messages` table.
COMMENT ON TABLE "public"."messages" IS 'Stores individual chat messages.';

-- Set up the primary key for the `messages` table.
ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_pkey" PRIMARY KEY USING INDEX ON "messages" ("id");

-- Add foreign key constraint to link messages to a conversation.
ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."conversations"("id") ON DELETE CASCADE;

-- Add foreign key constraint to link the sender to a user.
ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

-- Add foreign key constraint to link the receiver to a user.
ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;


-- ### SECURITY: Row Level Security (RLS) ###
-- Enable RLS for all tables to ensure data is secure by default.
-- Policies will be needed to grant specific access.
ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."providers" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."customers" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."reviews" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."agreements" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."conversations" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."messages" ENABLE ROW LEVEL SECURITY;


-- ### POLICIES ###

-- ** USERS TABLE POLICIES **
-- 1. Allow any user to see any public profile. User profiles are not sensitive.
CREATE POLICY "Allow public read access to all users" ON "public"."users"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

-- 2. Allow a user to update their own profile information.
CREATE POLICY "Allow users to update their own profile" ON "public"."users"
AS PERMISSIVE FOR UPDATE
TO authenticated
USING (("auth"."uid"() = "id"))
WITH CHECK (("auth"."uid"() = "id"));


-- ** PROVIDERS TABLE POLICIES **
-- 1. Allow any user to see all provider profiles. This is necessary for browsing services.
CREATE POLICY "Allow public read access to all providers" ON "public"."providers"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

-- 2. Allow a provider to update their own profile.
CREATE POLICY "Allow providers to update their own profile" ON "public"."providers"
AS PERMISSIVE FOR UPDATE
TO authenticated
USING (("auth"."uid"() = "user_id"))
WITH CHECK (("auth"."uid"() = "user_id"));


-- ** REVIEWS TABLE POLICIES **
-- 1. Allow public read access to all reviews.
CREATE POLICY "Allow public read access to all reviews" ON "public"."reviews"
AS PERMISSIVE FOR SELECT
TO public
USING (true);

-- 2. Allow authenticated users to insert a review.
CREATE POLICY "Allow authenticated users to insert reviews" ON "public"."reviews"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (true);


-- ** AGREEMENTS TABLE POLICIES **
-- 1. Allow users to see agreements where they are either the customer or the provider.
CREATE POLICY "Allow users to see their own agreements" ON "public"."agreements"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (("auth"."jwt"() ->> 'phone'::"text") = "customer_phone" OR ("auth"."jwt"() ->> 'phone'::"text") = "provider_phone");

-- 2. Allow authenticated users to insert new agreements.
CREATE POLICY "Allow authenticated users to insert agreements" ON "public"."agreements"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (true);

-- 3. Allow providers to update (confirm) their own agreements.
CREATE POLICY "Allow providers to update their agreements" ON "public"."agreements"
AS PERMISSIVE FOR UPDATE
TO authenticated
USING (("auth"."jwt"() ->> 'phone'::"text") = "provider_phone");


-- ### FUNCTIONS & TRIGGERS ###

-- Function to handle new user setup.
-- This function is triggered after a new user signs up in `auth.users`.
-- It creates a corresponding entry in the `public.users` table.
CREATE OR REPLACE FUNCTION "public"."handle_new_user"()
RETURNS "trigger"
LANGUAGE "plpgsql"
SECURITY DEFINER -- This function runs with the security context of the user who defined it (the admin).
AS $$
BEGIN
  INSERT INTO public.users (id, name, phone, account_type)
  VALUES (
    new.id,
    new.raw_user_meta_data ->> 'name',
    new.phone,
    new.raw_user_meta_data ->> 'account_type'
  );

  -- If the new user is a provider, also create a record in the providers table.
  IF (new.raw_user_meta_data ->> 'account_type' = 'provider') THEN
    INSERT INTO public.providers (user_id, name, phone, service, location, bio, category_slug, service_slug, profile_image)
    VALUES (
      new.id,
      new.raw_user_meta_data ->> 'name',
      new.phone,
      new.raw_user_meta_data ->> 'service',
      new.raw_user_meta_data ->> 'location',
      new.raw_user_meta_data ->> 'bio',
      new.raw_user_meta_data ->> 'category_slug',
      new.raw_user_meta_data ->> 'service_slug',
      '{"src": "", "ai_hint": "woman portrait"}'::jsonb
    );
  END IF;

  RETURN new;
END;
$$;

-- Create a trigger that calls the `handle_new_user` function after every new user is created.
CREATE TRIGGER "on_auth_user_created"
AFTER INSERT ON "auth"."users"
FOR EACH ROW EXECUTE FUNCTION "public"."handle_new_user"();


-- Function to get or create a conversation between two users.
-- This prevents duplicate conversations and simplifies the logic in the app.
CREATE OR REPLACE FUNCTION "public"."get_or_create_conversation"("p_user_id_1" "uuid", "p_user_id_2" "uuid")
RETURNS "public"."conversations"
LANGUAGE "plpgsql"
AS $$
DECLARE
    "v_conversation" "public"."conversations";
BEGIN
    -- Try to find an existing conversation
    SELECT *
    INTO "v_conversation"
    FROM "public"."conversations"
    WHERE ("participant_one_id" = "p_user_id_1" AND "participant_two_id" = "p_user_id_2")
       OR ("participant_one_id" = "p_user_id_2" AND "participant_two_id" = "p_user_id_1");

    -- If no conversation is found, create a new one
    IF "v_conversation" IS NULL THEN
        INSERT INTO "public"."conversations" ("participant_one_id", "participant_two_id")
        VALUES ("p_user_id_1", "p_user_id_2")
        RETURNING * INTO "v_conversation";
    END IF;

    RETURN "v_conversation";
END;
$$;

-- Function to get metadata for all conversations of a specific user.
-- This is highly efficient as it gets the last message and unread count for all conversations in one go.
CREATE OR REPLACE FUNCTION "public"."get_conversations_metadata"("user_id" "uuid")
RETURNS TABLE("conversation_id" "uuid", "last_message_content" "text", "unread_count" "bigint")
LANGUAGE "sql"
AS $$
    WITH "ranked_messages" AS (
        SELECT
            "m"."conversation_id",
            "m"."content",
            ROW_NUMBER() OVER(PARTITION BY "m"."conversation_id" ORDER BY "m"."created_at" DESC) as "rn"
        FROM "public"."messages" "m"
        JOIN "public"."conversations" "c" ON "m"."conversation_id" = "c"."id"
        WHERE "c"."participant_one_id" = "user_id" OR "c"."participant_two_id" = "user_id"
    ),
    "last_messages" AS (
        SELECT "conversation_id", "content"
        FROM "ranked_messages"
        WHERE "rn" = 1
    ),
    "unread_counts" AS (
        SELECT "conversation_id", COUNT(*) as "count"
        FROM "public"."messages"
        WHERE "receiver_id" = "user_id" AND "is_read" = false
        GROUP BY "conversation_id"
    )
    SELECT
        "c"."id" as "conversation_id",
        "lm"."content" as "last_message_content",
        COALESCE("uc"."count", 0) as "unread_count"
    FROM "public"."conversations" "c"
    LEFT JOIN "last_messages" "lm" ON "c"."id" = "lm"."conversation_id"
    LEFT JOIN "unread_counts" "uc" ON "c"."id" = "uc"."conversation_id"
    WHERE "c"."participant_one_id" = "user_id" OR "c"."participant_two_id" = "user_id";
$$;
