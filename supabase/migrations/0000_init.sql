
-- Create the users table
CREATE TABLE IF NOT EXISTS public.users (
    id uuid NOT NULL DEFAULT auth.uid() PRIMARY KEY,
    name character varying NOT NULL,
    phone character varying UNIQUE,
    account_type character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    profile_image jsonb
);
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own data" ON public.users FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own data" ON public.users FOR UPDATE USING (auth.uid() = id);


-- Create the providers table
CREATE TABLE IF NOT EXISTS public.providers (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    name character varying NOT NULL,
    phone character varying UNIQUE,
    service character varying,
    location character varying,
    bio text,
    category_slug character varying,
    service_slug character varying,
    rating double precision DEFAULT 0 NOT NULL,
    reviews_count integer DEFAULT 0 NOT NULL,
    profile_image jsonb,
    portfolio jsonb[],
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE public.providers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Providers are publicly visible" ON public.providers FOR SELECT USING (true);
CREATE POLICY "Providers can update their own profile" ON public.providers FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Providers can insert their own profile" ON public.providers FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Create the customers table
CREATE TABLE IF NOT EXISTS public.customers (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Customers can view their own profile" ON public.customers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Customers can insert their own profile" ON public.customers FOR INSERT WITH CHECK (auth.uid() = user_id);


-- Create the reviews table
CREATE TABLE IF NOT EXISTS public.reviews (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    provider_id bigint NOT NULL REFERENCES public.providers(id) ON DELETE CASCADE,
    customer_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    rating integer NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    customer_name character varying
);
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Reviews are publicly visible" ON public.reviews FOR SELECT USING (true);
CREATE POLICY "Authenticated users can post reviews" ON public.reviews FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Users can delete their own reviews" ON public.reviews FOR DELETE USING (auth.uid() = customer_id);


-- Create the conversations table
CREATE TABLE IF NOT EXISTS public.conversations (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    participant_one_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    participant_two_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    last_message_at timestamp with time zone,
    UNIQUE(participant_one_id, participant_two_id)
);
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can access their own conversations" ON public.conversations FOR SELECT USING (auth.uid() IN (participant_one_id, participant_two_id));

-- Create the messages table
CREATE TABLE IF NOT EXISTS public.messages (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    receiver_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    is_read boolean DEFAULT false NOT NULL
);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can send/receive messages in their conversations" ON public.messages FOR ALL USING (auth.uid() IN (sender_id, receiver_id));


-- Function to automatically create a user profile on new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.users (id, name, phone, account_type, profile_image)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'name',
    new.raw_user_meta_data->>'phone',
    new.raw_user_meta_data->>'account_type',
    ('{"src": "' || (new.raw_user_meta_data->>'picture') || '", "ai_hint": "profile picture"}')::jsonb
  );
  
  IF new.raw_user_meta_data->>'account_type' = 'provider' THEN
    INSERT INTO public.providers (user_id, name, phone, service, location, bio, category_slug, service_slug)
    VALUES (
      new.id,
      new.raw_user_meta_data->>'name',
      new.raw_user_meta_data->>'phone',
      new.raw_user_meta_data->>'service',
      new.raw_user_meta_data->>'location',
      new.raw_user_meta_data->>'bio',
      new.raw_user_meta_data->>'category_slug',
      new.raw_user_meta_data->>'service_slug'
    );
  ELSE
    INSERT INTO public.customers (user_id)
    VALUES (new.id);
  END IF;
  
  RETURN new;
END;
$$;

-- Trigger to call the function
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- RPC for getting or creating a conversation
CREATE OR REPLACE FUNCTION public.get_or_create_conversation(p_user_id_1 uuid, p_user_id_2 uuid)
RETURNS SETOF public.conversations
LANGUAGE plpgsql
AS $$
BEGIN
  -- Try to find an existing conversation
  IF EXISTS (
    SELECT 1 FROM public.conversations
    WHERE (participant_one_id = p_user_id_1 AND participant_two_id = p_user_id_2)
       OR (participant_one_id = p_user_id_2 AND participant_two_id = p_user_id_1)
  ) THEN
    -- Return existing conversation
    RETURN QUERY
    SELECT * FROM public.conversations
    WHERE (participant_one_id = p_user_id_1 AND participant_two_id = p_user_id_2)
       OR (participant_one_id = p_user_id_2 AND participant_two_id = p_user_id_1);
  ELSE
    -- Create and return new conversation
    RETURN QUERY
    INSERT INTO public.conversations (participant_one_id, participant_two_id)
    VALUES (p_user_id_1, p_user_id_2)
    RETURNING *;
  END IF;
END;
$$;

-- RPC for getting conversation metadata
CREATE OR REPLACE FUNCTION public.get_conversations_metadata(user_id uuid)
RETURNS TABLE(conversation_id uuid, unread_count bigint, last_message_content text)
LANGUAGE sql
STABLE
AS $$
  SELECT
    c.id as conversation_id,
    SUM(CASE WHEN m.receiver_id = user_id AND m.is_read = false THEN 1 ELSE 0 END)::bigint AS unread_count,
    (SELECT content FROM public.messages WHERE conversation_id = c.id ORDER BY created_at DESC LIMIT 1) AS last_message_content
  FROM
    public.conversations c
  LEFT JOIN
    public.messages m ON c.id = m.conversation_id
  WHERE
    c.participant_one_id = user_id OR c.participant_two_id = user_id
  GROUP BY
    c.id;
$$;
