-- Enable the pgcrypto extension if it's not already enabled.
create extension if not exists "pgcrypto" with schema "extensions";

-- Drop existing types and tables with cascade to ensure a clean slate.
DROP TYPE IF EXISTS public.user_account_type CASCADE;
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.conversations CASCADE;
DROP TABLE IF EXISTS public.reviews CASCADE;
DROP TABLE IF EXISTS public.agreements CASCADE;
DROP TABLE IF EXISTS public.providers CASCADE;
DROP TABLE IF EXISTS public.customers CASCADE;
DROP TABLE IF EXISTS public.users CASCADE;


-- Create a custom type for user account types.
create type "public"."user_account_type" as enum ('provider', 'customer');


-- Create the users table, which stores public profile information for all users.
create table "public"."users" (
    "id" uuid not null references auth.users(id) on delete cascade,
    "name" text not null,
    "phone" text not null,
    "account_type" user_account_type not null,
    "created_at" timestamp with time zone not null default now(),
    "profile_image" jsonb
);

alter table "public"."users" enable row level security;
CREATE UNIQUE INDEX users_phone_key ON public.users USING btree (phone);
CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);
alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";
alter table "public"."users" add constraint "users_phone_key" UNIQUE using index "users_phone_key";

-- Create the providers table for users who are service providers.
create table "public"."providers" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null references public.users(id) on delete cascade,
    "name" text not null,
    "phone" text not null,
    "service" text not null,
    "location" text not null,
    "bio" text not null,
    "category_slug" text not null,
    "service_slug" text not null,
    "rating" real not null default '0'::real,
    "reviews_count" integer not null default 0,
    "profile_image" jsonb,
    "portfolio" jsonb[],
    "created_at" timestamp with time zone not null default now()
);

alter table "public"."providers" enable row level security;
CREATE UNIQUE INDEX providers_pkey ON public.providers USING btree (id);
CREATE UNIQUE INDEX providers_user_id_key ON public.providers USING btree (user_id);
alter table "public"."providers" add constraint "providers_pkey" PRIMARY KEY using index "providers_pkey";
alter table "public"."providers" add constraint "providers_user_id_key" UNIQUE using index "providers_user_id_key";

-- Create the customers table for users who are customers.
create table "public"."customers" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null references public.users(id) on delete cascade,
    "created_at" timestamp with time zone not null default now()
);

alter table "public"."customers" enable row level security;
CREATE UNIQUE INDEX customers_pkey ON public.customers USING btree (id);
CREATE UNIQUE INDEX customers_user_id_key ON public.customers USING btree (user_id);
alter table "public"."customers" add constraint "customers_pkey" PRIMARY KEY using index "customers_pkey";
alter table "public"."customers" add constraint "customers_user_id_key" UNIQUE using index "customers_user_id_key";


-- Create the reviews table.
create table "public"."reviews" (
    "id" bigint generated by default as identity not null,
    "provider_id" bigint not null references public.providers(id) on delete cascade,
    "customer_id" uuid not null references public.users(id) on delete cascade,
    "rating" smallint not null,
    "comment" text,
    "created_at" timestamp with time zone not null default now(),
    "customer_name" text not null
);

alter table "public"."reviews" enable row level security;
CREATE INDEX reviews_provider_id_idx ON public.reviews USING btree (provider_id);
CREATE UNIQUE INDEX reviews_pkey ON public.reviews USING btree (id);
alter table "public"."reviews" add constraint "reviews_pkey" PRIMARY KEY using index "reviews_pkey";
alter table "public"."reviews" add constraint "reviews_rating_check" CHECK (((rating >= 1) AND (rating <= 5))) not valid;
alter table "public"."reviews" validate constraint "reviews_rating_check";

-- Create the agreements table.
create table "public"."agreements" (
    "id" bigint generated by default as identity not null,
    "customer_phone" text not null,
    "provider_phone" text not null,
    "status" text not null default 'pending'::text,
    "requested_at" timestamp with time zone not null default now(),
    "confirmed_at" timestamp with time zone
);

alter table "public"."agreements" enable row level security;
CREATE UNIQUE INDEX agreements_pkey ON public.agreements USING btree (id);
alter table "public"."agreements" add constraint "agreements_pkey" PRIMARY KEY using index "agreements_pkey";

-- Create the conversations table.
create table "public"."conversations" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "participant_one_id" uuid not null references public.users(id) on delete cascade,
    "participant_two_id" uuid not null references public.users(id) on delete cascade,
    "last_message_at" timestamp with time zone
);

alter table "public"."conversations" enable row level security;
CREATE UNIQUE INDEX conversations_pkey ON public.conversations USING btree (id);
alter table "public"."conversations" add constraint "conversations_pkey" PRIMARY KEY using index "conversations_pkey";
alter table "public"."conversations" add constraint "conversations_participant_one_id_fkey" FOREIGN KEY (participant_one_id) REFERENCES public.users(id) not valid;
alter table "public"."conversations" validate constraint "conversations_participant_one_id_fkey";
alter table "public"."conversations" add constraint "conversations_participant_two_id_fkey" FOREIGN KEY (participant_two_id) REFERENCES public.users(id) not valid;
alter table "public"."conversations" validate constraint "conversations_participant_two_id_fkey";

-- Create the messages table.
create table "public"."messages" (
    "id" uuid not null default gen_random_uuid(),
    "conversation_id" uuid not null references public.conversations(id) on delete cascade,
    "sender_id" uuid not null references public.users(id) on delete cascade,
    "receiver_id" uuid not null references public.users(id) on delete cascade,
    "content" text not null,
    "created_at" timestamp with time zone not null default now(),
    "is_read" boolean not null default false
);

alter table "public"."messages" enable row level security;
CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);
alter table "public"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";
alter table "public"."messages" add constraint "messages_conversation_id_fkey" FOREIGN KEY (conversation_id) REFERENCES public.conversations(id) not valid;
alter table "public"."messages" validate constraint "messages_conversation_id_fkey";
alter table "public"."messages" add constraint "messages_receiver_id_fkey" FOREIGN KEY (receiver_id) REFERENCES public.users(id) not valid;
alter table "public"."messages" validate constraint "messages_receiver_id_fkey";
alter table "public"."messages" add constraint "messages_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES public.users(id) not valid;
alter table "public"."messages" validate constraint "messages_sender_id_fkey";


-- Create security policies for all tables.
create policy "Enable read access for all users" on public.users for select using (true);
create policy "Enable read access for all users" on public.providers for select using (true);
create policy "Enable read access for all users" on public.reviews for select using (true);
create policy "Enable read access for all users" on public.agreements for select using (true);
create policy "Enable insert for authenticated users" on public.reviews for insert to authenticated with check (true);
create policy "Enable insert for authenticated users" on public.agreements for insert to authenticated with check (true);
create policy "Enable update for users based on user_id" on public.agreements for update to authenticated using (auth.uid() IN ( SELECT user_id FROM providers WHERE phone = agreements.provider_phone)) with check (auth.uid() IN ( SELECT user_id FROM providers WHERE phone = agreements.provider_phone));
create policy "Enable read access for participants" on public.conversations for select using (auth.uid() IN (participant_one_id, participant_two_id));
create policy "Enable read access for participants" on public.messages for select using (auth.uid() IN (sender_id, receiver_id));
create policy "Enable insert for participants" on public.messages for insert with check (auth.uid() = sender_id);
create policy "Enable update for receiver to mark as read" on public.messages for update using (auth.uid() = receiver_id);

-- This trigger function automatically creates a user profile when a new user signs up in Supabase Auth.
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.users (id, name, phone, account_type, profile_image)
  values (
    new.id,
    new.raw_user_meta_data->>'name',
    new.raw_user_meta_data->>'phone',
    (new.raw_user_meta_data->>'account_type')::user_account_type,
    (new.raw_user_meta_data->>'profile_image')::jsonb
  );

  if (new.raw_user_meta_data->>'account_type' = 'provider') then
    insert into public.providers (user_id, name, phone, service, location, bio, category_slug, service_slug, profile_image, portfolio)
    values (
      new.id,
      new.raw_user_meta_data->>'name',
      new.raw_user_meta_data->>'phone',
      new.raw_user_meta_data->>'service',
      new.raw_user_meta_data->>'location',
      new.raw_user_meta_data->>'bio',
      new.raw_user_meta_data->>'category_slug',
      new.raw_user_meta_data->>'service_slug',
      (new.raw_user_meta_data->>'profile_image')::jsonb,
      '{}'
    );
  elsif (new.raw_user_meta_data->>'account_type' = 'customer') then
    insert into public.customers (user_id)
    values (new.id);
  end if;
  return new;
end;
$$;

-- Create the trigger that calls the function after a new user is inserted into auth.users.
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- This trigger function updates the last_message_at timestamp in the conversations table whenever a new message is inserted.
create or replace function public.update_last_message_at()
returns trigger
language plpgsql
as $$
begin
  update public.conversations
  set last_message_at = new.created_at
  where id = new.conversation_id;
  return new;
end;
$$;

-- Create the trigger that calls the function after a new message is inserted.
create trigger on_new_message
  after insert on public.messages
  for each row execute procedure public.update_last_message_at();
