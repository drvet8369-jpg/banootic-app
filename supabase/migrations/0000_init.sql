-- Enable the pgcrypto extension for gen_random_uuid()
create extension if not exists "pgcrypto" with schema "extensions";

-- Drop existing objects in reverse order of dependency to avoid errors
drop table if exists "public"."messages" cascade;
drop table if exists "public"."conversations" cascade;
drop table if exists "public"."reviews" cascade;
drop table if exists "public"."agreements" cascade;
drop table if exists "public"."providers" cascade;
drop table if exists "public"."customers" cascade;
drop table if exists "public"."users" cascade;
drop type if exists "public"."user_account_type" cascade;

-- Create a custom type for user roles
create type "public"."user_account_type" as enum ('provider', 'customer');

-- Create the users table, the foundation for other tables
create table "public"."users" (
    "id" uuid primary key not null default extensions.gen_random_uuid(),
    "name" text not null,
    "phone" text not null unique,
    "account_type" public.user_account_type not null,
    "profile_image_src" text,
    "profile_image_ai_hint" text,
    "created_at" timestamp with time zone not null default now()
);
comment on table "public"."users" is 'Stores public user profile information.';

-- Create the providers table, linked to users
create table "public"."providers" (
    "id" bigint primary key generated by default as identity,
    "user_id" uuid not null references "public"."users"(id) on delete cascade,
    "name" text not null,
    "phone" text not null unique,
    "service" text not null,
    "location" text not null,
    "bio" text not null,
    "category_slug" text not null,
    "service_slug" text not null,
    "rating" real not null default 0,
    "reviews_count" integer not null default 0,
    "profile_image_src" text,
    "profile_image_ai_hint" text,
    "portfolio" jsonb not null default '[]'::jsonb,
    "created_at" timestamp with time zone not null default now()
);
comment on table "public"."providers" is 'Stores detailed information for service providers.';

-- Create the customers table, linked to users
create table "public"."customers" (
    "id" bigint primary key generated by default as identity,
    "user_id" uuid not null references "public"."users"(id) on delete cascade,
    "created_at" timestamp with time zone not null default now()
);
comment on table "public"."customers" is 'Stores information for customers.';

-- Create the reviews table
create table "public"."reviews" (
    "id" bigint primary key generated by default as identity,
    "provider_id" bigint not null references "public"."providers"(id) on delete cascade,
    "customer_id" uuid not null references "public"."users"(id) on delete cascade,
    "rating" real not null check (rating >= 1 and rating <= 5),
    "comment" text,
    "customer_name" text not null,
    "created_at" timestamp with time zone not null default now()
);
comment on table "public"."reviews" is 'Stores customer reviews for providers.';

-- Create the agreements table
create table "public"."agreements" (
    "id" bigint primary key generated by default as identity,
    "customer_phone" text not null,
    "provider_phone" text not null,
    "status" text not null default 'pending',
    "requested_at" timestamp with time zone not null default now(),
    "confirmed_at" timestamp with time zone
);
comment on table "public"."agreements" is 'Tracks service agreements between customers and providers.';

-- Create conversations table
create table "public"."conversations" (
    "id" uuid primary key not null default extensions.gen_random_uuid(),
    "participant_one_id" uuid not null references "public"."users"(id) on delete cascade,
    "participant_two_id" uuid not null references "public"."users"(id) on delete cascade,
    "last_message_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    constraint "participants_unique" unique ("participant_one_id", "participant_two_id")
);
comment on table "public"."conversations" is 'Represents a chat conversation between two users.';

-- Create messages table
create table "public"."messages" (
    "id" uuid primary key not null default extensions.gen_random_uuid(),
    "conversation_id" uuid not null references "public"."conversations"(id) on delete cascade,
    "sender_id" uuid not null references "public"."users"(id) on delete cascade,
    "receiver_id" uuid not null references "public"."users"(id) on delete cascade,
    "content" text not null,
    "is_read" boolean not null default false,
    "created_at" timestamp with time zone not null default now()
);
comment on table "public"."messages" is 'Stores individual chat messages for a conversation.';


-- Enable Row Level Security (RLS) for all tables
alter table "public"."users" enable row level security;
alter table "public"."providers" enable row level security;
alter table "public"."customers" enable row level security;
alter table "public"."reviews" enable row level security;
alter table "public"."agreements" enable row level security;
alter table "public"."conversations" enable row level security;
alter table "public"."messages" enable row level security;

-- Create RLS policies

-- Users can see all profiles, but only edit their own.
create policy "Public user profiles are viewable by everyone." on "public"."users" for select using (true);
create policy "Users can insert their own profile." on "public"."users" for insert with check (auth.uid() = id);
create policy "Users can update their own profile." on "public"."users" for update using (auth.uid() = id) with check (auth.uid() = id);

-- Providers can be viewed by anyone, but only edited by the owning user.
create policy "Public providers are viewable by everyone." on "public"."providers" for select using (true);
create policy "Providers can insert their own data." on "public"."providers" for insert with check (auth.uid() = user_id);
create policy "Providers can update their own data." on "public"."providers" for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Customers can only manage their own entry.
create policy "Customers can manage their own data." on "public"."customers" for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- Reviews can be seen by anyone, but only created by authenticated users.
create policy "Public reviews are viewable by everyone." on "public"."reviews" for select using (true);
create policy "Authenticated users can create reviews." on "public"."reviews" for insert with check (auth.role() = 'authenticated');
create policy "Users can delete their own reviews." on "public"."reviews" for delete using (auth.uid() = customer_id);

-- Agreements can be seen by participants, created by customers, and updated by providers.
create policy "Agreements are visible to participants." on "public"."agreements" for select using (
  (select phone from public.users where id = auth.uid()) = provider_phone or
  (select phone from public.users where id = auth.uid()) = customer_phone
);
create policy "Customers can create agreements." on "public"."agreements" for insert with check (
  auth.role() = 'authenticated' and (select phone from public.users where id = auth.uid()) = customer_phone
);
create policy "Providers can update (confirm) agreements." on "public"."agreements" for update using (
  (select phone from public.users where id = auth.uid()) = provider_phone
);

-- Users can only access conversations they are a part of.
create policy "Users can access their own conversations." on "public"."conversations" for all
using ( auth.uid() = participant_one_id or auth.uid() = participant_two_id )
with check ( auth.uid() = participant_one_id or auth.uid() = participant_two_id );

-- Users can only access messages in conversations they are a part of.
create policy "Users can access messages in their conversations." on "public"."messages" for all
using (
    conversation_id in (
        select id from public.conversations where auth.uid() = participant_one_id or auth.uid() = participant_two_id
    )
)
with check (
    auth.uid() = sender_id
);

-- RPC function to get or create a conversation
create or replace function public.get_or_create_conversation(
    p_user_id_1 uuid,
    p_user_id_2 uuid
)
returns table (
    id uuid,
    created_at timestamp with time zone,
    participant_one_id uuid,
    participant_two_id uuid,
    last_message_at timestamp with time zone
)
language plpgsql
as $$
declare
    v_conversation_id uuid;
    v_ordered_user_id_1 uuid;
    v_ordered_user_id_2 uuid;
begin
    -- Ensure consistent ordering of user IDs to prevent duplicate conversations
    if p_user_id_1 < p_user_id_2 then
        v_ordered_user_id_1 := p_user_id_1;
        v_ordered_user_id_2 := p_user_id_2;
    else
        v_ordered_user_id_1 := p_user_id_2;
        v_ordered_user_id_2 := p_user_id_1;
    end if;

    -- Attempt to find an existing conversation
    select c.id into v_conversation_id
    from public.conversations c
    where c.participant_one_id = v_ordered_user_id_1
      and c.participant_two_id = v_ordered_user_id_2;

    -- If no conversation is found, create a new one
    if v_conversation_id is null then
        insert into public.conversations (participant_one_id, participant_two_id)
        values (v_ordered_user_id_1, v_ordered_user_id_2)
        returning conversations.id into v_conversation_id;
    end if;

    -- Return the details of the existing or new conversation
    return query
    select *
    from public.conversations
    where conversations.id = v_conversation_id;
end;
$$;


-- RPC function to get metadata for conversations list
create or replace function public.get_conversations_metadata(user_id uuid)
returns table (
    conversation_id uuid,
    last_message_content text,
    unread_count bigint
)
language sql
security definer
as $$
    select
        c.id as conversation_id,
        (
            select m.content
            from public.messages m
            where m.conversation_id = c.id
            order by m.created_at desc
            limit 1
        ) as last_message_content,
        (
            select count(*)
            from public.messages m
            where m.conversation_id = c.id
              and m.receiver_id = user_id
              and m.is_read = false
        ) as unread_count
    from
        public.conversations c
    where
        c.participant_one_id = user_id or c.participant_two_id = user_id;
$$;
