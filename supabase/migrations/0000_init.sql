-- This script will reset and rebuild the entire database schema.
-- WARNING: All existing data will be lost.

-- Drop tables in reverse order of dependency, using CASCADE to handle dependencies.
DROP TABLE IF EXISTS "public"."messages" CASCADE;
DROP TABLE IF EXISTS "public"."conversations" CASCADE;
DROP TABLE IF EXISTS "public"."agreements" CASCADE;
DROP TABLE IF EXISTS "public"."reviews" CASCADE;
DROP TABLE IF EXISTS "public"."providers" CASCADE;
DROP TABLE IF EXISTS "public"."customers" CASCADE;
DROP TABLE IF EXISTS "public"."users" CASCADE;

-- Drop custom types
DROP TYPE IF EXISTS "public"."user_account_type";
DROP TYPE IF EXISTS "public"."agreement_status";

-- Step 1: Enable necessary extensions
create extension if not exists "pgcrypto" with schema "extensions";

-- Step 2: Create custom data types
create type "public"."user_account_type" as enum ('provider', 'customer');
create type "public"."agreement_status" as enum ('pending', 'confirmed');

-- Step 3: Create the 'users' table (foundation)
create table "public"."users" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "phone" text not null,
    "account_type" public.user_account_type not null,
    "created_at" timestamp with time zone not null default now(),
    "profile_image" jsonb
);

-- Add comments for clarity
comment on column "public"."users"."id" is 'Links to auth.users.id';

-- Step 4: Create dependent tables
create table "public"."providers" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "name" text not null,
    "phone" text not null,
    "service" text not null,
    "location" text not null,
    "bio" text not null,
    "category_slug" text not null,
    "service_slug" text not null,
    "rating" real not null default '0'::real,
    "reviews_count" integer not null default 0,
    "profile_image" jsonb,
    "portfolio" jsonb[],
    "created_at" timestamp with time zone not null default now()
);

create table "public"."customers" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "created_at" timestamp with time zone not null default now()
);

create table "public"."reviews" (
    "id" bigint generated by default as identity not null,
    "provider_id" bigint not null,
    "customer_id" uuid not null,
    "rating" integer not null default 0,
    "comment" text,
    "created_at" timestamp with time zone not null default now(),
    "customer_name" text not null,
    constraint "reviews_rating_check" check (((rating >= 0) AND (rating <= 5)))
);

create table "public"."agreements" (
    "id" bigint generated by default as identity not null,
    "customer_phone" text not null,
    "provider_phone" text not null,
    "status" public.agreement_status not null default 'pending'::public.agreement_status,
    "requested_at" timestamp with time zone not null default now(),
    "confirmed_at" timestamp with time zone
);

create table "public"."conversations" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "participant_one_id" uuid not null,
    "participant_two_id" uuid not null,
    "last_message_at" timestamp with time zone
);

create table "public"."messages" (
    "id" uuid not null default gen_random_uuid(),
    "conversation_id" uuid not null,
    "sender_id" uuid not null,
    "receiver_id" uuid not null,
    "content" text,
    "created_at" timestamp with time zone not null default now(),
    "is_read" boolean not null default false
);

-- Step 5: Setup Primary and Foreign Keys
ALTER TABLE "public"."users" ADD CONSTRAINT "users_pkey" PRIMARY KEY using index ("id");
ALTER TABLE "public"."users" ADD CONSTRAINT "users_phone_key" UNIQUE using index ("phone");
ALTER TABLE "public"."users" ADD CONSTRAINT "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "public"."customers" ADD CONSTRAINT "customers_pkey" PRIMARY KEY using index ("id");
ALTER TABLE "public"."customers" ADD CONSTRAINT "customers_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE "public"."providers" ADD CONSTRAINT "providers_pkey" PRIMARY KEY using index ("id");
ALTER TABLE "public"."providers" ADD CONSTRAINT "providers_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE "public"."reviews" ADD CONSTRAINT "reviews_pkey" PRIMARY KEY using index ("id");
ALTER TABLE "public"."reviews" ADD CONSTRAINT "reviews_customer_id_fkey" FOREIGN KEY (customer_id) REFERENCES public.users(id) ON DELETE CASCADE;
ALTER TABLE "public"."reviews" ADD CONSTRAINT "reviews_provider_id_fkey" FOREIGN KEY (provider_id) REFERENCES public.providers(id) ON DELETE CASCADE;

ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_pkey" PRIMARY KEY using index ("id");
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_participant_one_id_fkey" FOREIGN KEY (participant_one_id) REFERENCES public.users(id) ON DELETE CASCADE;
ALTER TABLE "public"."conversations" ADD CONSTRAINT "conversations_participant_two_id_fkey" FOREIGN KEY (participant_two_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_pkey" PRIMARY KEY using index ("id");
ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_conversation_id_fkey" FOREIGN KEY (conversation_id) REFERENCES public.conversations(id) ON DELETE CASCADE;
ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_receiver_id_fkey" FOREIGN KEY (receiver_id) REFERENCES public.users(id) ON DELETE CASCADE;
ALTER TABLE "public"."messages" ADD CONSTRAINT "messages_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES public.users(id) ON DELETE CASCADE;


-- Step 6: Enable Row Level Security for all tables
alter table "public"."users" enable row level security;
alter table "public"."providers" enable row level security;
alter table "public"."customers" enable row level security;
alter table "public"."reviews" enable row level security;
alter table "public"."agreements" enable row level security;
alter table "public"."conversations" enable row level security;
alter table "public"."messages" enable row level security;


-- Step 7: Create security policies
-- Policies for 'users'
create policy "Allow public read access to all users" on "public"."users" for select using (true);
create policy "Allow individual user to update their own profile" on "public"."users" for update using ((select auth.uid()) = id);

-- Policies for 'providers'
create policy "Allow public read access to all providers" on "public"."providers" for select using (true);
create policy "Allow provider to update their own details" on "public"."providers" for update using ((select auth.uid()) = user_id);

-- Policies for 'reviews'
create policy "Allow public read access to all reviews" on "public"."reviews" for select using (true);
create policy "Allow authenticated users to insert reviews" on "public"."reviews" for insert with check (auth.role() = 'authenticated'::text);

-- Policies for 'agreements'
create policy "Allow authenticated users to create agreements" on "public"."agreements" for insert with check (auth.role() = 'authenticated'::text);
create policy "Allow provider or customer to read their agreements" on "public"."agreements" for select using (((select auth.jwt() ->> 'phone'::text) = provider_phone) OR ((select auth.jwt() ->> 'phone'::text) = customer_phone));
create policy "Allow provider to update their agreement" on "public"."agreements" for update using (((select auth.jwt() ->> 'phone'::text) = provider_phone));

-- Policies for 'conversations'
create policy "Allow participants to view their conversations" on "public"."conversations" for select using (((select auth.uid()) = participant_one_id) OR ((select auth.uid()) = participant_two_id));

-- Policies for 'messages'
create policy "Allow participants to view messages in their conversations" on "public"."messages" for select using (conversation_id IN (SELECT c.id FROM conversations c WHERE ((c.participant_one_id = (select auth.uid())) OR (c.participant_two_id = (select auth.uid())))));
create policy "Allow participants to insert messages in their conversations" on "public"."messages" for insert with check (((select auth.uid()) = sender_id));
