-- Honarbanoo DB Schema V1 - Full Reset and Rebuild
-- This script first DROPS all existing related tables to ensure a clean state,
-- then rebuilds the entire schema from scratch with the correct structure and order.

-- STEP 0: Drop existing objects in reverse order of dependency to avoid errors.
-- This ensures a clean slate and resolves any inconsistencies from previous failed attempts.
DROP TABLE IF EXISTS "public"."agreements";
DROP TABLE IF EXISTS "public"."reviews";
DROP TABLE IF EXISTS "public"."messages";
DROP TABLE IF EXISTS "public"."conversations";
DROP TABLE IF EXISTS "public"."customers";
DROP TABLE IF EXISTS "public"."providers";
DROP TABLE IF EXISTS "public"."users";
DROP TYPE IF EXISTS "public"."user_account_type";

-- STEP 1: Enable necessary extensions
-- We need pgcrypto to generate UUIDs for our primary keys.
CREATE EXTENSION IF NOT EXISTS "extensions"."pgcrypto" WITH SCHEMA "extensions";

-- STEP 2: Create custom data types
-- This ENUM type ensures that user accounts can only be 'provider' or 'customer'.
CREATE TYPE "public"."user_account_type" AS ENUM ('provider', 'customer');

-- STEP 3: Create the core 'users' table
-- This table is linked to Supabase's auth.users and holds public profile info.
CREATE TABLE "public"."users" (
    "id"         uuid PRIMARY KEY NOT NULL DEFAULT extensions.gen_random_uuid(),
    "name"       text NOT NULL,
    "phone"      text NOT NULL UNIQUE,
    "account_type" public.user_account_type NOT NULL,
    "created_at" timestamp with time zone NOT NULL DEFAULT now()
);
-- Add a foreign key constraint to link our public users table to the auth users table.
ALTER TABLE "public"."users" ADD CONSTRAINT "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- STEP 4: Create the 'providers' table
-- This table stores specific information for users who are service providers.
CREATE TABLE "public"."providers" (
    "id"            bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id"       uuid NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    "name"          text NOT NULL,
    "phone"         text NOT NULL UNIQUE,
    "service"       text NOT NULL,
    "location"      text NOT NULL,
    "bio"           text NOT NULL,
    "category_slug" text NOT NULL,
    "service_slug"  text NOT NULL,
    "rating"        real NOT NULL DEFAULT 0,
    "reviews_count" integer NOT NULL DEFAULT 0,
    "profile_image" jsonb,
    "portfolio"     jsonb[],
    "created_at"    timestamp with time zone NOT NULL DEFAULT now()
);

-- STEP 5: Create the 'customers' table
-- This table stores specific information for users who are customers.
CREATE TABLE "public"."customers" (
    "id"         bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id"    uuid NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    "created_at" timestamp with time zone NOT NULL DEFAULT now()
);

-- STEP 6: Create the 'reviews' table
-- This table holds all reviews left by customers for providers.
CREATE TABLE "public"."reviews" (
    "id"            bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "provider_id"   bigint NOT NULL REFERENCES public.providers(id) ON DELETE CASCADE,
    "customer_id"   uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "rating"        integer NOT NULL CHECK (rating >= 1 AND rating <= 5),
    "comment"       text,
    "customer_name" text NOT NULL,
    "created_at"    timestamp with time zone NOT NULL DEFAULT now()
);

-- STEP 7: Create the 'agreements' table
-- This table tracks service agreements between customers and providers.
CREATE TABLE "public"."agreements" (
    "id"             bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "customer_phone" text NOT NULL,
    "provider_phone" text NOT NULL,
    "status"         text NOT NULL DEFAULT 'pending',
    "requested_at"   timestamp with time zone NOT NULL DEFAULT now(),
    "confirmed_at"   timestamp with time zone
);
ALTER TABLE public.agreements ADD CONSTRAINT agreements_provider_phone_fkey FOREIGN KEY (provider_phone) REFERENCES public.providers(phone) ON DELETE CASCADE;

-- STEP 8: Create conversation & message tables for chat functionality
CREATE TABLE "public"."conversations" (
    "id" uuid PRIMARY KEY NOT NULL DEFAULT extensions.gen_random_uuid(),
    "created_at" timestamp with time zone NOT NULL DEFAULT now(),
    "participant_one_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "participant_two_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "last_message_at" timestamp with time zone,
    CONSTRAINT participants_unique UNIQUE (participant_one_id, participant_two_id)
);

CREATE TABLE "public"."messages" (
    "id" uuid PRIMARY KEY NOT NULL DEFAULT extensions.gen_random_uuid(),
    "conversation_id" uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    "sender_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "receiver_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "content" text NOT NULL,
    "is_read" boolean NOT NULL DEFAULT false,
    "created_at" timestamp with time zone NOT NULL DEFAULT now()
);


-- STEP 9: Enable Row Level Security (RLS) for all tables
-- This is a critical security step. By default, no one can access any data.
-- We will define specific access policies (permissions) below.
ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."providers" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."customers" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."reviews" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."agreements" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."conversations" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."messages" ENABLE ROW LEVEL SECURITY;

-- STEP 10: Create Security Policies (Permissions)
-- These policies define who can do what with the data.

-- Users can see all user profiles, but can only update their own.
CREATE POLICY "Public user profiles are viewable by everyone." ON "public"."users" FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON "public"."users" FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON "public"."users" FOR UPDATE USING (auth.uid() = id);

-- Providers are public and can be viewed by anyone. Only the provider can update their own info.
CREATE POLICY "Providers are viewable by everyone." ON "public"."providers" FOR SELECT USING (true);
CREATE POLICY "Providers can insert their own profile." ON "public"."providers" FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Providers can update their own profile." ON "public"."providers" FOR UPDATE USING (auth.uid() = user_id);

-- Customers can only manage their own entry.
CREATE POLICY "Customers can manage their own profile." ON "public"."customers" FOR ALL USING (auth.uid() = user_id);

-- Reviews can be seen by anyone, but only created/managed by the author.
CREATE POLICY "Reviews are viewable by everyone." ON "public"."reviews" FOR SELECT USING (true);
CREATE POLICY "Users can insert their own reviews." ON "public"."reviews" FOR INSERT WITH CHECK (auth.uid() = customer_id);
CREATE POLICY "Users can update their own reviews." ON "public"."reviews" FOR UPDATE USING (auth.uid() = customer_id);

-- Agreements can only be seen by the participants or created by customers.
CREATE POLICY "Agreements are visible to participants." ON "public"."agreements" FOR SELECT USING (
    (SELECT account_type FROM users WHERE phone = provider_phone) = 'provider' AND auth.uid() = (SELECT id FROM users WHERE phone = provider_phone) OR
    (SELECT account_type FROM users WHERE phone = customer_phone) = 'customer' AND auth.uid() = (SELECT id FROM users WHERE phone = customer_phone)
);
CREATE POLICY "Customers can create agreements." ON "public"."agreements" FOR INSERT WITH CHECK (
    auth.uid() = (SELECT id FROM users WHERE phone = customer_phone)
);
CREATE POLICY "Providers can update agreements (to confirm)." ON "public"."agreements" FOR UPDATE USING (
    auth.uid() = (SELECT id FROM users WHERE phone = provider_phone)
);

-- Conversations can only be accessed by their participants.
CREATE POLICY "Participants can view their conversations." ON "public"."conversations" FOR SELECT USING (auth.uid() = participant_one_id OR auth.uid() = participant_two_id);

-- Messages can only be accessed by the sender or receiver.
CREATE POLICY "Participants can view messages in their conversations." ON "public"."messages" FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send messages." ON "public"."messages" FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can update their own messages (for is_read)." ON "public"."messages" FOR UPDATE USING (auth.uid() = receiver_id);
