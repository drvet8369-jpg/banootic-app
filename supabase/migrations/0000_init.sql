-- Create a table for public user profiles
CREATE TABLE users (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name VARCHAR(255),
    phone VARCHAR(20) UNIQUE,
    account_type VARCHAR(50) CHECK (account_type IN ('customer', 'provider')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Set up Row Level Security (RLS)
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON users FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON users FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON users FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- Create a table for providers, linking to the users table
CREATE TABLE providers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(20) UNIQUE,
    service TEXT,
    location TEXT,
    bio TEXT,
    category_slug VARCHAR(100),
    service_slug VARCHAR(100),
    rating NUMERIC(2, 1) DEFAULT 0.0,
    reviews_count INT DEFAULT 0,
    profile_image JSONB,
    portfolio JSONB[],
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE providers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Providers are viewable by everyone." ON providers FOR SELECT USING (true);
CREATE POLICY "Providers can insert their own profile." ON providers FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM users WHERE users.id = providers.user_id AND users.account_type = 'provider' AND auth.uid() = users.id));
CREATE POLICY "Providers can update their own profile." ON providers FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Create a table for customers, linking to the users table
CREATE TABLE customers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Customers are viewable by owner." ON customers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Customers can insert their own profile." ON customers FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM users WHERE users.id = customers.user_id AND users.account_type = 'customer' AND auth.uid() = users.id));

-- Create a table for reviews
CREATE TABLE reviews (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    provider_id BIGINT NOT NULL REFERENCES providers(id) ON DELETE CASCADE,
    customer_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    customer_name VARCHAR(255),
    rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE reviews ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Reviews are viewable by everyone." ON reviews FOR SELECT USING (true);
CREATE POLICY "Authenticated users can insert reviews." ON reviews FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Create a table for agreements between customers and providers
CREATE TABLE agreements (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_phone VARCHAR(20) NOT NULL,
    provider_phone VARCHAR(20) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed')),
    requested_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    confirmed_at TIMESTAMPTZ
);

ALTER TABLE agreements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Agreements are viewable by involved parties." ON agreements FOR SELECT USING (EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND (users.phone = agreements.customer_phone OR users.phone = agreements.provider_phone)));
CREATE POLICY "Customers can create agreements." ON agreements FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND users.phone = agreements.customer_phone));
CREATE POLICY "Providers can update status to confirmed." ON agreements FOR UPDATE USING (EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND users.phone = agreements.provider_phone)) WITH CHECK (status = 'confirmed');

-- Create conversations table
CREATE TABLE conversations (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    participant_one_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    participant_two_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    last_message_at TIMESTAMPTZ,
    CONSTRAINT unique_conversation UNIQUE (participant_one_id, participant_two_id)
);

ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Participants can view their conversations." ON conversations FOR SELECT USING (auth.uid() = participant_one_id OR auth.uid() = participant_two_id);
CREATE POLICY "Participants can create conversations." ON conversations FOR INSERT WITH CHECK (auth.uid() = participant_one_id OR auth.uid() = participant_two_id);

-- Create messages table
CREATE TABLE messages (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id uuid NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    receiver_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    is_read BOOLEAN DEFAULT false
);

ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Participants can view messages in their conversation." ON messages FOR SELECT USING (EXISTS (SELECT 1 FROM conversations WHERE conversations.id = messages.conversation_id AND (conversations.participant_one_id = auth.uid() OR conversations.participant_two_id = auth.uid())));
CREATE POLICY "Users can send messages." ON messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Receivers can mark messages as read." ON messages FOR UPDATE USING (auth.uid() = receiver_id) WITH CHECK (is_read = true);


-- Create Supabase storage bucket for images if it doesn't exist
INSERT INTO storage.buckets (id, name, public)
VALUES ('images', 'images', true)
ON CONFLICT (id) DO NOTHING;

CREATE POLICY "Public access to images" ON storage.objects FOR SELECT USING (bucket_id = 'images');
CREATE POLICY "Authenticated users can upload images" ON storage.objects FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Users can update their own images" ON storage.objects FOR UPDATE USING (auth.uid() = owner);
CREATE POLICY "Users can delete their own images" ON storage.objects FOR DELETE USING (auth.uid() = owner);


-- Function to get or create a conversation
CREATE OR REPLACE FUNCTION get_or_create_conversation(p_user_id_1 uuid, p_user_id_2 uuid)
RETURNS TABLE(id uuid, created_at TIMESTAMPTZ, participant_one_id uuid, participant_two_id uuid, last_message_at TIMESTAMPTZ) AS $$
DECLARE
    v_conversation_id uuid;
BEGIN
    -- Order the user IDs to ensure the pair is always unique in the same order
    IF p_user_id_1 < p_user_id_2 THEN
        SELECT c.id INTO v_conversation_id FROM conversations c WHERE c.participant_one_id = p_user_id_1 AND c.participant_two_id = p_user_id_2;
    ELSE
        SELECT c.id INTO v_conversation_id FROM conversations c WHERE c.participant_one_id = p_user_id_2 AND c.participant_two_id = p_user_id_1;
    END IF;

    IF v_conversation_id IS NULL THEN
        -- Conversation does not exist, create it
        IF p_user_id_1 < p_user_id_2 THEN
            INSERT INTO conversations (participant_one_id, participant_two_id)
            VALUES (p_user_id_1, p_user_id_2)
            RETURNING conversations.id INTO v_conversation_id;
        ELSE
            INSERT INTO conversations (participant_one_id, participant_two_id)
            VALUES (p_user_id_2, p_user_id_1)
            RETURNING conversations.id INTO v_conversation_id;
        END IF;
    END IF;

    RETURN QUERY SELECT * FROM conversations WHERE conversations.id = v_conversation_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get conversation metadata
CREATE OR REPLACE FUNCTION get_conversations_metadata(user_id uuid)
RETURNS TABLE (
    conversation_id uuid,
    last_message_content text,
    unread_count bigint
) AS $$
BEGIN
    RETURN QUERY
    WITH last_messages AS (
        SELECT
            m.conversation_id,
            m.content,
            ROW_NUMBER() OVER(PARTITION BY m.conversation_id ORDER BY m.created_at DESC) as rn
        FROM messages m
    )
    SELECT
        c.id as conversation_id,
        lm.content as last_message_content,
        (
            SELECT COUNT(*)
            FROM messages m
            WHERE m.conversation_id = c.id
            AND m.receiver_id = user_id
            AND m.is_read = false
        ) as unread_count
    FROM conversations c
    LEFT JOIN last_messages lm ON c.id = lm.conversation_id AND lm.rn = 1
    WHERE c.participant_one_id = user_id OR c.participant_two_id = user_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update last_message_at in conversations
CREATE OR REPLACE FUNCTION update_last_message_at()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE conversations
  SET last_message_at = NEW.created_at
  WHERE id = NEW.conversation_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_new_message
  AFTER INSERT ON messages
  FOR EACH ROW
  EXECUTE FUNCTION update_last_message_at();
  
-- Trigger to sync public.users from auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, name, phone, account_type)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'name',
    NEW.raw_user_meta_data->>'phone',
    NEW.raw_user_meta_data->>'account_type'
  );

  IF NEW.raw_user_meta_data->>'account_type' = 'provider' THEN
    INSERT INTO public.providers (user_id, name, phone, service, location, bio, category_slug, service_slug, profile_image, portfolio)
    VALUES (
      NEW.id,
      NEW.raw_user_meta_data->>'name',
      NEW.raw_user_meta_data->>'phone',
      NEW.raw_user_meta_data->>'service',
      NEW.raw_user_meta_data->>'location',
      NEW.raw_user_meta_data->>'bio',
      NEW.raw_user_meta_data->>'category_slug',
      NEW.raw_user_meta_data->>'service_slug',
      '{"src": "", "ai_hint": "woman portrait"}',
      '{}'
    );
  ELSIF NEW.raw_user_meta_data->>'account_type' = 'customer' THEN
     INSERT INTO public.customers (user_id) VALUES (NEW.id);
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop trigger if exists to avoid conflicts
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Enable real-time for tables
ALTER PUBLICATION supabase_realtime ADD TABLE messages;
ALTER PUBLICATION supabase_realtime ADD TABLE conversations;
ALTER PUBLICATION supabase_realtime ADD TABLE agreements;
