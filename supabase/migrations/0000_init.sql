-- Step 1: Clean up old objects if they exist, using CASCADE to handle dependencies.
DROP TABLE if EXISTS "public"."messages" CASCADE;
DROP TABLE if EXISTS "public"."conversations" CASCADE;
DROP TABLE if EXISTS "public"."reviews" CASCADE;
DROP TABLE if EXISTS "public"."agreements" CASCADE;
DROP TABLE if EXISTS "public"."providers" CASCADE;
DROP TABLE if EXISTS "public"."customers" CASCADE;
DROP TABLE if EXISTS "public"."users" CASCADE;
DROP TYPE if EXISTS "public"."user_account_type" CASCADE;

-- Step 2: Enable necessary extensions.
create extension if not exists "pgcrypto" with schema "extensions";

-- Step 3: Define custom types.
create type "public"."user_account_type" as enum ('provider', 'customer');

-- Step 4: Create the base 'users' table.
create table "public"."users" (
    "id" uuid primary key not null default extensions.gen_random_uuid(),
    "name" text not null,
    "phone" text not null unique,
    "account_type" public.user_account_type not null,
    "created_at" timestamp with time zone not null default now()
);

-- Step 5: Create the 'providers' table.
create table "public"."providers" (
    "id" bigint generated by default as identity primary key,
    "user_id" uuid not null references public.users(id) on delete cascade,
    "name" text not null,
    "phone" text not null,
    "service" text not null,
    "location" text not null,
    "bio" text not null,
    "category_slug" text not null,
    "service_slug" text not null,
    "rating" real not null default 0,
    "reviews_count" integer not null default 0,
    "profile_image" jsonb,
    "portfolio" jsonb[],
    "created_at" timestamp with time zone not null default now()
);

-- Step 6: Create the 'customers' table.
create table "public"."customers" (
    "id" bigint generated by default as identity primary key,
    "user_id" uuid not null references public.users(id) on delete cascade,
    "created_at" timestamp with time zone not null default now()
);

-- Step 7: Create the 'reviews' table.
create table "public"."reviews" (
    "id" bigint generated by default as identity primary key,
    "provider_id" bigint not null references public.providers(id) on delete cascade,
    "customer_id" uuid not null references public.users(id) on delete cascade,
    "rating" integer not null default 0,
    "comment" text not null,
    "created_at" timestamp with time zone not null default now(),
    "customer_name" text not null
);

-- Step 8: Create the 'agreements' table.
create table "public"."agreements" (
    "id" bigint generated by default as identity primary key,
    "customer_phone" text not null,
    "provider_phone" text not null,
    "status" text not null default 'pending'::text,
    "requested_at" timestamp with time zone not null default now(),
    "confirmed_at" timestamp with time zone
);

-- Step 9: Create the 'conversations' table.
create table "public"."conversations" (
    "id" uuid primary key not null default extensions.gen_random_uuid(),
    "participant_one_id" uuid not null references public.users(id) on delete cascade,
    "participant_two_id" uuid not null references public.users(id) on delete cascade,
    "last_message_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    constraint "unique_participants" unique ("participant_one_id", "participant_two_id")
);

-- Step 10: Create the 'messages' table.
create table "public"."messages" (
    "id" uuid primary key not null default extensions.gen_random_uuid(),
    "conversation_id" uuid not null references public.conversations(id) on delete cascade,
    "sender_id" uuid not null references public.users(id) on delete cascade,
    "receiver_id" uuid not null references public.users(id) on delete cascade,
    "content" text not null,
    "is_read" boolean not null default false,
    "created_at" timestamp with time zone not null default now()
);

-- Step 11: Enable Row Level Security for all tables.
alter table public.users enable row level security;
alter table public.providers enable row level security;
alter table public.customers enable row level security;
alter table public.reviews enable row level security;
alter table public.agreements enable row level security;
alter table public.conversations enable row level security;
alter table public.messages enable row level security;

-- Step 12: Define Policies for all tables.
-- Users can see their own profile.
create policy "Users can view their own data" on public.users for select using (auth.uid() = id);
-- Anyone can see any provider's profile.
create policy "Allow public read access to providers" on public.providers for select using (true);
-- Reviews are publicly visible.
create policy "Allow public read access to reviews" on public.reviews for select using (true);
-- Users can see their own conversations.
create policy "Users can view their own conversations" on public.conversations for select using (auth.uid() = participant_one_id or auth.uid() = participant_two_id);
-- Users can see messages in their own conversations.
create policy "Users can view messages in their conversations" on public.messages for select using (
  exists (
    select 1 from conversations
    where conversations.id = messages.conversation_id
      and (conversations.participant_one_id = auth.uid() or conversations.participant_two_id = auth.uid())
  )
);
-- Users can insert messages into their conversations.
create policy "Users can insert messages into their conversations" on public.messages for insert with check (
  sender_id = auth.uid() and
  exists (
    select 1 from conversations
    where conversations.id = messages.conversation_id
      and (conversations.participant_one_id = auth.uid() or conversations.participant_two_id = auth.uid())
  )
);
-- Agreements can be viewed by participants.
create policy "Participants can view their agreements" on public.agreements for select using (
  exists (select 1 from users where users.phone = agreements.customer_phone and users.id = auth.uid()) or
  exists (select 1 from users where users.phone = agreements.provider_phone and users.id = auth.uid())
);
-- Authenticated users can insert new agreements.
create policy "Authenticated users can create agreements" on public.agreements for insert with check (auth.role() = 'authenticated');
-- Providers can update agreements to confirm them.
create policy "Providers can update their agreements" on public.agreements for update using (
  exists (select 1 from users where users.phone = agreements.provider_phone and users.id = auth.uid())
);
