
-- Full database reset and schema definition for Banotik.
-- Version 4.0 - Final Corrected Version

-- Step 1: Drop existing objects in reverse order of dependency to avoid errors.
-- This ensures a clean slate for rebuilding the schema.

-- Drop dependent tables first
DROP TABLE IF EXISTS "public"."messages" CASCADE;
DROP TABLE IF EXISTS "public"."conversations" CASCADE;
DROP TABLE IF EXISTS "public"."reviews" CASCADE;
DROP TABLE IF EXISTS "public"."agreements" CASCADE;
DROP TABLE IF EXISTS "public"."providers" CASCADE;
DROP TABLE IF EXISTS "public"."customers" CASCADE;

-- Drop the primary user table after its dependencies are gone
DROP TABLE IF EXISTS "public"."users" CASCADE;

-- Drop dependent functions and types if they exist
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.get_or_create_conversation(uuid, uuid);
DROP FUNCTION IF EXISTS public.get_conversations_metadata(uuid);


-- Step 2: Recreate all tables with the corrected schema.

-- Users table: Central table for all authenticated users.
CREATE TABLE "public"."users" (
    "id" uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    "name" text NOT NULL,
    "phone" text NOT NULL UNIQUE,
    "account_type" text NOT NULL CHECK (account_type IN ('customer', 'provider')),
    "created_at" timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public users are viewable by everyone." ON users FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON users FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON users FOR UPDATE USING (auth.uid() = id);


-- Providers table: Stores detailed profiles for service providers.
CREATE TABLE "public"."providers" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id" uuid NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    "name" text NOT NULL,
    "phone" text NOT NULL UNIQUE,
    "service" text NOT NULL,
    "location" text NOT NULL,
    "bio" text NOT NULL,
    "category_slug" text NOT NULL,
    "service_slug" text NOT NULL,
    "rating" real NOT NULL DEFAULT 0,
    "reviews_count" integer NOT NULL DEFAULT 0,
    "profile_image" jsonb,
    "portfolio" jsonb,
    "created_at" timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE "public"."providers" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Providers are viewable by everyone." ON providers FOR SELECT USING (true);
CREATE POLICY "Providers can insert their own profile." ON providers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Providers can update their own profile." ON providers FOR UPDATE USING (auth.uid() = user_id);

-- Customers table: Placeholder for future customer-specific data.
CREATE TABLE "public"."customers" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id" uuid NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    "created_at" timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE "public"."customers" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Customers can view their own data." ON customers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Customers can insert their own profile." ON customers FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Reviews table: Stores customer reviews for providers.
CREATE TABLE "public"."reviews" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "provider_id" bigint NOT NULL REFERENCES public.providers(id) ON DELETE CASCADE,
    "customer_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "rating" integer NOT NULL CHECK (rating >= 1 AND rating <= 5),
    "comment" text,
    "customer_name" text NOT NULL,
    "created_at" timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE "public"."reviews" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Reviews are viewable by everyone." ON reviews FOR SELECT USING (true);
CREATE POLICY "Authenticated users can insert reviews." ON reviews FOR INSERT WITH CHECK (auth.role() = 'authenticated');


-- Agreements table: Manages service agreements between customers and providers.
CREATE TABLE "public"."agreements" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "customer_phone" text NOT NULL,
    "provider_phone" text NOT NULL,
    "status" text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed')),
    "requested_at" timestamptz NOT NULL DEFAULT now(),
    "confirmed_at" timestamptz
);
ALTER TABLE "public"."agreements" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own agreements." ON agreements FOR SELECT USING (
    (EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND users.phone = agreements.customer_phone)) OR
    (EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND users.phone = agreements.provider_phone))
);
CREATE POLICY "Customers can create agreements." ON agreements FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND users.phone = agreements.customer_phone)
);
CREATE POLICY "Providers can update status to confirmed." ON agreements FOR UPDATE USING (
    EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND users.phone = agreements.provider_phone)
);


-- Conversations table: Manages chat sessions between two users.
CREATE TABLE "public"."conversations" (
    "id" uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    "participant_one_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "participant_two_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "created_at" timestamptz NOT NULL DEFAULT now(),
    "last_message_at" timestamptz,
    CONSTRAINT "participants_check" CHECK (participant_one_id < participant_two_id) -- Ensures unique conversation for a pair
);
ALTER TABLE "public"."conversations" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view conversations they are part of." ON conversations FOR SELECT USING (
    auth.uid() = participant_one_id OR auth.uid() = participant_two_id
);

-- Messages table: Stores individual chat messages within a conversation.
CREATE TABLE "public"."messages" (
    "id" uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    "conversation_id" uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    "sender_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "receiver_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "content" text NOT NULL,
    "is_read" boolean NOT NULL DEFAULT false,
    "created_at" timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE "public"."messages" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view messages in their conversations." ON messages FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM conversations
        WHERE conversations.id = messages.conversation_id
        AND (conversations.participant_one_id = auth.uid() OR conversations.participant_two_id = auth.uid())
    )
);
CREATE POLICY "Users can send messages." ON messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can mark messages they received as read." ON messages FOR UPDATE USING (auth.uid() = receiver_id) WITH CHECK (auth.uid() = receiver_id);


-- Step 3: Recreate database functions and triggers.

-- Function to automatically create a user profile upon new auth sign-up.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER -- This is important for the function to have the right permissions.
AS $$
BEGIN
  -- Insert a new row into the public.users table
  INSERT INTO public.users (id, name, phone, account_type)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data ->> 'name',
    NEW.raw_user_meta_data ->> 'phone',
    NEW.raw_user_meta_data ->> 'account_type'
  );

  -- If the user is a provider, also create an entry in the providers table
  IF (NEW.raw_user_meta_data ->> 'account_type') = 'provider' THEN
    INSERT INTO public.providers (user_id, name, phone, service, bio, category_slug, service_slug, location, profile_image, portfolio)
    VALUES (
      NEW.id,
      NEW.raw_user_meta_data ->> 'name',
      NEW.raw_user_meta_data ->> 'phone',
      NEW.raw_user_meta_data ->> 'service',
      NEW.raw_user_meta_data ->> 'bio',
      NEW.raw_user_meta_data ->> 'category_slug',
      NEW.raw_user_meta_data ->> 'service_slug',
      COALESCE(NEW.raw_user_meta_data ->> 'location', 'ارومیه'),
      '{"src": "", "ai_hint": "woman portrait"}',
      '[]'
    );
  END IF;
  
  RETURN NEW;
END;
$$;

-- Trigger to call the function after a new user is created in auth.users.
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- Function to get or create a conversation between two users.
CREATE OR REPLACE FUNCTION public.get_or_create_conversation(p_user_id_1 uuid, p_user_id_2 uuid)
RETURNS TABLE(id uuid, created_at timestamptz, participant_one_id uuid, participant_two_id uuid, last_message_at timestamptz)
LANGUAGE plpgsql
AS $$
DECLARE
    v_conversation_id uuid;
    user1_id uuid;
    user2_id uuid;
BEGIN
    -- Ensure consistent ordering of participants
    IF p_user_id_1 < p_user_id_2 THEN
        user1_id := p_user_id_1;
        user2_id := p_user_id_2;
    ELSE
        user1_id := p_user_id_2;
        user2_id := p_user_id_1;
    END IF;

    -- Attempt to find an existing conversation
    SELECT c.id INTO v_conversation_id
    FROM conversations c
    WHERE c.participant_one_id = user1_id AND c.participant_two_id = user2_id;

    -- If no conversation exists, create a new one
    IF v_conversation_id IS NULL THEN
        INSERT INTO conversations (participant_one_id, participant_two_id)
        VALUES (user1_id, user2_id)
        RETURNING conversations.id INTO v_conversation_id;
    END IF;

    -- Return the details of the found or newly created conversation
    RETURN QUERY SELECT * FROM conversations c WHERE c.id = v_conversation_id;
END;
$$;


-- Function to get metadata (last message, unread count) for a user's conversations.
CREATE OR REPLACE FUNCTION public.get_conversations_metadata(user_id uuid)
RETURNS TABLE(conversation_id uuid, last_message_content text, unread_count bigint)
LANGUAGE sql
STABLE -- Indicates the function does not modify the database
AS $$
  SELECT
    c.id as conversation_id,
    (
        SELECT m.content
        FROM messages m
        WHERE m.conversation_id = c.id
        ORDER BY m.created_at DESC
        LIMIT 1
    ) as last_message_content,
    (
        SELECT COUNT(*)
        FROM messages m
        WHERE m.conversation_id = c.id
        AND m.receiver_id = user_id
        AND m.is_read = false
    ) as unread_count
  FROM conversations c
  WHERE c.participant_one_id = user_id OR c.participant_two_id = user_id;
$$;

-- Grant usage on functions to the authenticated role
GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_or_create_conversation(uuid, uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_conversations_metadata(uuid) TO authenticated;


-- Final step: Enable real-time for relevant tables
alter publication supabase_realtime add table messages;
alter publication supabase_realtime add table conversations;
alter publication supabase_realtime add table agreements;


-- --- END OF MIGRATION SCRIPT ---
