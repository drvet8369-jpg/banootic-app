-- Enable Realtime for the 'messages' table
begin;
  -- remove the publication if it exists
  drop publication if exists supabase_realtime;

  -- re-create the publication but don't publish any tables
  create publication supabase_realtime;
commit;

-- Add the 'messages' table to the publication
alter publication supabase_realtime add table messages;

-- Create the 'messages' table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.messages (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    chat_id text NOT NULL,
    sender_id uuid NOT NULL,
    receiver_id uuid,
    content text NOT NULL,
    CONSTRAINT messages_pkey PRIMARY KEY (id),
    CONSTRAINT messages_sender_id_fkey FOREIGN KEY (sender_id) REFERENCES auth.users (id) ON DELETE CASCADE
);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Create Policies for 'messages' table
CREATE POLICY "Users can view their own messages." ON public.messages
    FOR SELECT
    USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

CREATE POLICY "Users can insert their own messages." ON public.messages
    FOR INSERT
    WITH CHECK (auth.uid() = sender_id);
    

-- Function to get user conversations
CREATE OR REPLACE FUNCTION public.get_user_conversations(p_user_id uuid)
RETURNS TABLE(chat_id text, other_user_id uuid, other_user_phone text, last_message_content text, last_message_at timestamp with time zone, unread_count bigint)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH last_messages AS (
    SELECT
      m.chat_id,
      m.content,
      m.created_at,
      m.sender_id,
      m.receiver_id,
      ROW_NUMBER() OVER(PARTITION BY m.chat_id ORDER BY m.created_at DESC) as rn
    FROM public.messages m
    WHERE m.sender_id = p_user_id OR m.receiver_id = p_user_id
  )
  SELECT
    lm.chat_id,
    CASE
      WHEN lm.sender_id = p_user_id THEN lm.receiver_id
      ELSE lm.sender_id
    END AS other_user_id,
    -- Determine other user's phone by joining with auth.users
    u.phone AS other_user_phone,
    lm.content AS last_message_content,
    lm.created_at AS last_message_at,
    0::bigint AS unread_count -- Placeholder for unread count logic
  FROM last_messages lm
  JOIN auth.users u ON u.id = (
    CASE
        WHEN lm.sender_id = p_user_id THEN lm.receiver_id
        ELSE lm.sender_id
    END
  )
  WHERE lm.rn = 1;
END;
$$;