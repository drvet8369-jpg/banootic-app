-- Drop existing policies on messages if they exist
DROP POLICY IF EXISTS "Users can view their own messages" ON public.messages;
DROP POLICY IF EXISTS "Users can insert their own messages" ON public.messages;

-- Drop existing function if it exists
DROP FUNCTION IF EXISTS public.get_user_conversations(text);

-- Drop existing tables if they exist to ensure a clean slate
DROP TABLE IF EXISTS public.messages;
DROP TABLE IF EXISTS public.agreements;
DROP TABLE IF EXISTS public.reviews;
DROP TABLE IF EXISTS public.providers;
DROP TABLE IF EXISTS public.customers;
DROP TABLE IF EXISTS public.users;


-- Create users table to hold basic user info and account type
CREATE TABLE public.users (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    phone text NOT NULL UNIQUE,
    account_type text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    PRIMARY KEY (id)
);

-- Create providers table
CREATE TABLE public.providers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    service text NOT NULL,
    location text NOT NULL,
    phone text NOT NULL UNIQUE,
    bio text NOT NULL,
    category_slug text NOT NULL,
    service_slug text NOT NULL,
    rating numeric(2,1) DEFAULT 0.0 NOT NULL,
    reviews_count integer DEFAULT 0 NOT NULL,
    profile_image jsonb,
    portfolio jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    PRIMARY KEY (id)
);

-- Create customers table
CREATE TABLE public.customers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    phone text NOT NULL UNIQUE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    PRIMARY KEY (id)
);

-- Create reviews table
CREATE TABLE public.reviews (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    provider_id uuid NOT NULL REFERENCES public.providers(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    author_name text NOT NULL,
    rating integer NOT NULL,
    comment text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    PRIMARY KEY (id)
);

-- Create agreements table
CREATE TABLE public.agreements (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    provider_id uuid NOT NULL REFERENCES public.providers(id),
    provider_phone text NOT NULL,
    customer_id uuid NOT NULL REFERENCES public.users(id),
    customer_phone text NOT NULL,
    customer_name text NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    requested_at timestamp with time zone DEFAULT now() NOT NULL,
    confirmed_at timestamp with time zone,
    PRIMARY KEY (id),
    UNIQUE (provider_id, customer_id)
);

-- Create messages table with correct column names
CREATE TABLE public.messages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    chat_id text NOT NULL,
    sender_phone text NOT NULL,
    receiver_phone text NOT NULL,
    content text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    PRIMARY KEY (id)
);

-- Enable RLS for all relevant tables
ALTER TABLE public.providers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.agreements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Policies for Messages
CREATE POLICY "Users can view their own messages" ON public.messages FOR SELECT
USING (auth.uid() = (SELECT user_id FROM public.users WHERE phone = sender_phone) OR auth.uid() = (SELECT user_id FROM public.users WHERE phone = receiver_phone));

CREATE POLICY "Users can insert their own messages" ON public.messages FOR INSERT
WITH CHECK (auth.uid() = (SELECT user_id FROM public.users WHERE phone = sender_phone));

-- RPC to get conversations
CREATE OR REPLACE FUNCTION get_user_conversations(p_user_phone text)
RETURNS TABLE(
    chat_id text,
    other_user_phone text,
    other_user_name text,
    other_user_avatar text,
    last_message_content text,
    last_message_at timestamp with time zone,
    unread_count integer
)
AS $$
BEGIN
    RETURN QUERY
    WITH all_users AS (
      SELECT u.phone, u.name, p.profile_image->>'src' as avatar
      FROM public.users u
      LEFT JOIN public.providers p ON u.phone = p.phone
      UNION
      SELECT u.phone, u.name, null as avatar
      FROM public.users u
      LEFT JOIN public.customers c ON u.phone = c.phone
      WHERE NOT EXISTS (SELECT 1 FROM public.providers WHERE phone = u.phone)
    ),
    ranked_messages AS (
        SELECT 
            m.*,
            ROW_NUMBER() OVER(PARTITION BY m.chat_id ORDER BY m.created_at DESC) as rn
        FROM 
            public.messages m
        WHERE 
            m.sender_phone = p_user_phone OR m.receiver_phone = p_user_phone
    )
    SELECT 
        rm.chat_id,
        CASE 
            WHEN rm.sender_phone = p_user_phone THEN rm.receiver_phone
            ELSE rm.sender_phone 
        END AS other_user_phone,
        u.name AS other_user_name,
        u.avatar AS other_user_avatar,
        rm.content AS last_message_content,
        rm.created_at AS last_message_at,
        0 AS unread_count -- Unread count logic to be added
    FROM 
        ranked_messages rm
    JOIN 
        all_users u ON u.phone = (CASE WHEN rm.sender_phone = p_user_phone THEN rm.receiver_phone ELSE rm.sender_phone END)
    WHERE 
        rm.rn = 1
    ORDER BY 
        rm.created_at DESC;
END;
$$ language plpgsql security definer;
