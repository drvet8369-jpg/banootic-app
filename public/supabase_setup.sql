-- Drop existing policies and functions to avoid "already exists" errors.
DROP POLICY IF EXISTS "Users can view their own messages" ON public.messages;
DROP POLICY IF EXISTS "Users can insert their own messages" ON public.messages;
DROP FUNCTION IF EXISTS public.get_user_conversations(uuid);


-- Create a table for public messages
CREATE TABLE IF NOT EXISTS public.messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    chat_id text NOT NULL,
    sender_id uuid NOT NULL,
    receiver_id uuid NOT NULL,
    content text NOT NULL,
    read boolean DEFAULT false
);

-- Enable Realtime for the messages table
ALTER TABLE public.messages REPLICA IDENTITY FULL;
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_publication WHERE pubname = 'supabase_realtime') THEN
    CREATE PUBLICATION supabase_realtime;
  END IF;
  ALTER PUBLICATION supabase_realtime ADD TABLE public.messages;
END $$;


-- Set up Row Level Security (RLS)
-- 1. Enable RLS on the table
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- 2. Create policies
CREATE POLICY "Users can view their own messages"
ON public.messages FOR SELECT
USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

CREATE POLICY "Users can insert their own messages"
ON public.messages FOR INSERT
WITH CHECK (auth.uid() = sender_id);


-- Database function to get user's conversations
-- This function fetches the last message for each chat involving the specified user
-- and joins with provider/customer tables to get the other user's details.
create or replace function public.get_user_conversations(p_user_id uuid)
returns table(
    chat_id text,
    other_user_id uuid,
    other_user_name text,
    other_user_phone text,
    other_user_avatar text,
    last_message_content text,
    last_message_at timestamptz,
    unread_count bigint
)
as $$
begin
  return query
  with message_partners as (
    -- Find all distinct chat partners for the given user
    select distinct
      m.chat_id,
      case
        when m.sender_id = p_user_id then m.receiver_id
        else m.sender_id
      end as other_user_id
    from messages m
    where m.sender_id = p_user_id or m.receiver_id = p_user_id
  ),
  last_messages as (
    -- Get the most recent message for each chat_id using a window function
    select
      chat_id,
      content,
      created_at
    from (
      select
        chat_id,
        content,
        created_at,
        row_number() over(partition by chat_id order by created_at desc) as rn
      from messages
    ) as ranked_messages
    where rn = 1
  )
  -- Join everything together to build the final output
  select
    mp.chat_id,
    mp.other_user_id,
    coalesce(u.name, 'کاربر حذف شده') as other_user_name,
    coalesce(p.phone, c.phone, '00000000000') as other_user_phone,
    p.profile_image->>'src' as other_user_avatar,
    lm.content as last_message_content,
    lm.created_at as last_message_at,
    0::bigint as unread_count -- Placeholder for unread count
  from
    message_partners mp
  left join
    public.users u on u.id = mp.other_user_id
  left join
    public.providers p on p.user_id = mp.other_user_id
  left join
    public.customers c on c.user_id = mp.other_user_id
  left join
    last_messages lm on lm.chat_id = mp.chat_id
  order by
    lm.created_at desc;
end;
$$ language plpgsql security definer;
