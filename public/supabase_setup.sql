-- This script sets up the database tables, policies, and functions for the Banotik app.

-- 1. Enable HTTP extension if not already enabled
create extension if not exists http with schema extensions;

-- 2. Create the central 'users' table
-- This table stores the core information for all users, linking their auth identity to their profile.
create table if not exists public.users (
  id uuid references auth.users not null primary key,
  name text,
  phone text not null unique,
  account_type text check (account_type in ('provider', 'customer'))
);

-- 3. Create the 'providers' table for service providers
-- This table holds profile information specific to providers.
create table if not exists public.providers (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  service text not null,
  location text not null,
  phone text not null unique,
  bio text not null,
  category_slug text not null,
  service_slug text not null,
  rating numeric default 0,
  reviews_count integer default 0,
  profile_image jsonb,
  portfolio jsonb[]
);

-- 4. Create the 'customers' table for customers
-- This table holds profile information specific to customers.
create table if not exists public.customers (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  phone text not null unique
);

-- 5. Create the 'reviews' table
create table if not exists public.reviews (
  id uuid primary key default gen_random_uuid(),
  provider_id uuid not null references public.providers(id) on delete cascade,
  user_id uuid not null references public.users(id) on delete cascade,
  author_name text not null,
  rating integer not null check (rating >= 1 and rating <= 5),
  comment text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 6. Create the 'agreements' table
create table if not exists public.agreements (
    id bigint generated by default as identity primary key,
    provider_id uuid not null references public.providers(id),
    customer_id uuid not null references public.users(id),
    provider_phone text not null,
    customer_phone text not null,
    customer_name text not null,
    status text default 'pending' check (status in ('pending', 'confirmed')),
    requested_at timestamp with time zone default timezone('utc'::text, now()) not null,
    confirmed_at timestamp with time zone,
    unique(provider_id, customer_id)
);

-- 7. Create the 'messages' table for chat functionality
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  chat_id text not null,
  sender_id uuid not null references public.users(id),
  receiver_id uuid not null references public.users(id),
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);


-- 8. Set up Row Level Security (RLS) for all tables
-- This ensures that users can only access data they are permitted to.
alter table public.users enable row level security;
alter table public.providers enable row level security;
alter table public.customers enable row level security;
alter table public.reviews enable row level security;
alter table public.agreements enable row level security;
alter table public.messages enable row level security;

-- 9. Define RLS Policies

-- USERS Table
drop policy if exists "Users can see their own data" on public.users;
create policy "Users can see their own data" on public.users for select
  using (auth.uid() = id);

drop policy if exists "Users can update their own data" on public.users;
create policy "Users can update their own data" on public.users for update
  using (auth.uid() = id);

-- PROVIDERS Table
drop policy if exists "Anyone can view provider profiles" on public.providers;
create policy "Anyone can view provider profiles" on public.providers for select
  using (true);

drop policy if exists "Providers can insert their own profile" on public.providers;
create policy "Providers can insert their own profile" on public.providers for insert
  with check (auth.uid() = user_id);

drop policy if exists "Providers can update their own profile" on public.providers;
create policy "Providers can update their own profile" on public.providers for update
  using (auth.uid() = user_id);

-- CUSTOMERS Table
drop policy if exists "Anyone can view customer profiles" on public.customers;
create policy "Anyone can view customer profiles" on public.customers for select
  using (true);

-- REVIEWS Table
drop policy if exists "Anyone can view reviews" on public.reviews;
create policy "Anyone can view reviews" on public.reviews for select
  using (true);

drop policy if exists "Authenticated users can insert reviews" on public.reviews;
create policy "Authenticated users can insert reviews" on public.reviews for insert
  with check (auth.role() = 'authenticated');

-- AGREEMENTS Table
drop policy if exists "Users can view their own agreements" on public.agreements;
create policy "Users can view their own agreements" on public.agreements for select
  using (auth.uid() = customer_id or auth.uid() in (select user_id from providers where phone = provider_phone));

drop policy if exists "Customers can create agreements" on public.agreements;
create policy "Customers can create agreements" on public.agreements for insert
  with check (auth.uid() = customer_id);

drop policy if exists "Providers can update agreement status" on public.agreements;
create policy "Providers can update agreement status" on public.agreements for update
  using (auth.uid() in (select user_id from providers where phone = provider_phone));
  
-- MESSAGES Table
drop policy if exists "Users can view their own messages" on public.messages;
create policy "Users can view their own messages" on public.messages for select
  using (auth.uid() = sender_id or auth.uid() = receiver_id);

drop policy if exists "Users can insert their own messages" on public.messages;
create policy "Users can insert their own messages" on public.messages for insert
  with check (auth.uid() = sender_id);
  

-- 10. Create the function to get user conversations for the inbox
drop function if exists public.get_user_conversations(uuid);
drop function if exists public.get_user_conversations(p_user_id uuid);
create or replace function public.get_user_conversations(p_user_id uuid)
returns table(
    chat_id text,
    other_user_id uuid,
    other_user_name text,
    other_user_avatar text,
    other_user_phone text,
    last_message_content text,
    last_message_at timestamp with time zone
)
language sql
security definer
as $$
  with last_messages as (
    select
      m.chat_id,
      m.content,
      m.created_at,
      m.sender_id,
      m.receiver_id,
      row_number() over(partition by m.chat_id order by m.created_at desc) as rn
    from
      public.messages m
    where m.sender_id = p_user_id or m.receiver_id = p_user_id
  )
  select
    lm.chat_id,
    -- Determine the other user's ID
    case
      when lm.sender_id = p_user_id then lm.receiver_id
      else lm.sender_id
    end as other_user_id,
    -- Get the other user's name
    u.name as other_user_name,
    -- Get the other user's avatar from the providers table if they are a provider
    (select p.profile_image->>'src' from public.providers p where p.user_id = u.id) as other_user_avatar,
    -- Get the other user's phone
    u.phone as other_user_phone,
    lm.content as last_message_content,
    lm.created_at as last_message_at
  from
    last_messages lm
  join
    public.users u on u.id = (
      case
        when lm.sender_id = p_user_id then lm.receiver_id
        else lm.sender_id
      end
    )
  where lm.rn = 1
  order by lm.created_at desc;
$$;