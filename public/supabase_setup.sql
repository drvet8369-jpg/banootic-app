-- This script sets up the necessary tables, policies, and functions for the Banotik application.
-- It is designed to be idempotent, meaning it can be run multiple times without causing errors.

-- 1. Create Tables if they do not exist
-- Users Table: Stores basic user information and links to customer/provider profiles.
CREATE TABLE IF NOT EXISTS public.users (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name character varying,
    phone text NOT NULL UNIQUE,
    account_type text NOT NULL
);

-- Providers Table: Stores detailed information about service providers.
CREATE TABLE IF NOT EXISTS public.providers (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name character varying NOT NULL,
    service text,
    location text,
    phone text NOT NULL UNIQUE,
    bio text,
    category_slug text,
    service_slug text,
    rating real DEFAULT 0 NOT NULL,
    reviews_count integer DEFAULT 0 NOT NULL,
    profile_image jsonb,
    portfolio jsonb[]
);

-- Customers Table: Stores information about customers.
CREATE TABLE IF NOT EXISTS public.customers (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text,
    phone text NOT NULL UNIQUE
);

-- Reviews Table: Stores reviews left by customers for providers.
CREATE TABLE IF NOT EXISTS public.reviews (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    provider_id uuid NOT NULL REFERENCES public.providers(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    author_name text,
    rating real NOT NULL,
    comment text
);

-- Agreements Table: Tracks service agreements between customers and providers.
CREATE TABLE IF NOT EXISTS public.agreements (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    provider_id uuid NOT NULL REFERENCES public.providers(id) ON DELETE CASCADE,
    customer_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    status text DEFAULT 'pending'::text,
    requested_at timestamp with time zone DEFAULT now(),
    confirmed_at timestamp with time zone,
    provider_phone text NOT NULL,
    customer_phone text NOT NULL,
    customer_name text,
    UNIQUE (provider_id, customer_id)
);

-- Messages Table: Stores chat messages between users.
CREATE TABLE IF NOT EXISTS public.messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    chat_id text,
    sender_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    receiver_id uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    content text
);


-- 2. Enable Row Level Security (RLS) for all relevant tables.
-- This is a critical security measure. By default, it denies all access.
-- We will then grant specific permissions using policies.
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.providers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.agreements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;


-- 3. Define RLS Policies for each table.
-- We use `DROP POLICY IF EXISTS` to make the script idempotent.

-- Policies for `users` table
DROP POLICY IF EXISTS "Allow public read access to users" ON public.users;
CREATE POLICY "Allow public read access to users" ON public.users FOR SELECT USING (true);


-- Policies for `providers` table
DROP POLICY IF EXISTS "Allow public read access to providers" ON public.providers;
CREATE POLICY "Allow public read access to providers" ON public.providers FOR SELECT USING (true);

DROP POLICY IF EXISTS "Allow individual update access to own provider profile" ON public.providers;
CREATE POLICY "Allow individual update access to own provider profile" ON public.providers FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Policies for `customers` table
DROP POLICY IF EXISTS "Allow public read access to customers" ON public.customers;
CREATE POLICY "Allow public read access to customers" ON public.customers FOR SELECT USING (true);

-- Policies for `reviews` table
DROP POLICY IF EXISTS "Allow insert access to authenticated users" ON public.reviews;
CREATE POLICY "Allow insert access to authenticated users" ON public.reviews FOR INSERT TO authenticated WITH CHECK (true);

DROP POLICY IF EXISTS "Allow read access to all" ON public.reviews;
CREATE POLICY "Allow read access to all" ON public.reviews FOR SELECT USING (true);

-- Policies for `agreements` table
DROP POLICY IF EXISTS "Enable insert for authenticated users only" ON public.agreements;
CREATE POLICY "Enable insert for authenticated users only" ON public.agreements FOR INSERT TO authenticated WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Enable read access for involved parties" ON public.agreements;
CREATE POLICY "Enable read access for involved parties" ON public.agreements FOR SELECT USING (
    (SELECT phone FROM public.users WHERE id = auth.uid()) = provider_phone OR
    (SELECT phone FROM public.users WHERE id = auth.uid()) = customer_phone
);

DROP POLICY IF EXISTS "Enable update for providers on their agreements" ON public.agreements;
CREATE POLICY "Enable update for providers on their agreements" ON public.agreements FOR UPDATE USING ((SELECT phone FROM public.users WHERE id = auth.uid()) = provider_phone) WITH CHECK ((SELECT phone FROM public.users WHERE id = auth.uid()) = provider_phone);

-- Policies for `messages` table
DROP POLICY IF EXISTS "Allow read access to involved parties in a chat" ON public.messages;
CREATE POLICY "Allow read access to involved parties in a chat" ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

DROP POLICY IF EXISTS "Allow insert access to sender" ON public.messages;
CREATE POLICY "Allow insert access to sender" ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);


-- 4. Create Database Functions
-- We use `CREATE OR REPLACE FUNCTION` to make the script idempotent.

-- Function to get user login details from either providers or customers table.
CREATE OR REPLACE FUNCTION public.get_user_login_details(p_phone text)
RETURNS TABLE(id uuid, name text, phone text, account_type text)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, u.name, u.phone, u.account_type
    FROM public.users u
    WHERE u.phone = p_phone;
END;
$$;


-- Function to get a user's conversations for the inbox.
CREATE OR REPLACE FUNCTION public.get_user_conversations(p_user_id uuid)
RETURNS TABLE(chat_id text, other_user_id uuid, other_user_name text, other_user_avatar text, other_user_phone text, last_message_content text, last_message_at timestamp with time zone)
LANGUAGE sql STABLE
AS $$
    WITH last_messages AS (
        SELECT
            m.chat_id,
            m.content,
            m.created_at,
            CASE
                WHEN m.sender_id = p_user_id THEN m.receiver_id
                ELSE m.sender_id
            END AS other_user_id,
            ROW_NUMBER() OVER(PARTITION BY m.chat_id ORDER BY m.created_at DESC) as rn
        FROM public.messages m
        WHERE m.sender_id = p_user_id OR m.receiver_id = p_user_id
    )
    SELECT
        lm.chat_id,
        lm.other_user_id,
        u.name AS other_user_name,
        COALESCE(p.profile_image->>'src', NULL) as other_user_avatar,
        u.phone as other_user_phone,
        lm.content AS last_message_content,
        lm.created_at AS last_message_at
    FROM last_messages lm
    JOIN public.users u ON lm.other_user_id = u.id
    LEFT JOIN public.providers p ON lm.other_user_id = p.user_id
    WHERE lm.rn = 1
    ORDER BY lm.created_at DESC;
$$;


-- 5. Create Supabase Storage Bucket for images
-- Note: This part cannot be done via SQL. It must be done in the Supabase Dashboard.
-- Ensure a bucket named 'images' exists with public access.
-- The RLS policies for storage objects are also managed in the dashboard.
-- Example policies for the 'images' bucket:
--
-- Target: profile-pics/
-- Allow SELECT for: All users (anon, authenticated)
-- Allow INSERT for: authenticated
-- Example policy for INSERT:
-- (bucket_id = 'images' AND auth.uid()::text = (storage.foldername(name))[2])
-- This allows a user to upload only to a folder named after their own user_id.

-- The end of the setup script.
