-- Drop the function if it exists to avoid 'cannot change return type' error
DROP FUNCTION IF EXISTS get_user_conversations(p_user_id uuid);

-- 1. Create the messages table
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  chat_id text not null,
  sender_id uuid references public.users(id) on delete cascade not null,
  receiver_id uuid references public.users(id) on delete cascade not null,
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Indexes for performance
create index if not exists messages_chat_id_idx on public.messages(chat_id);
create index if not exists messages_sender_id_idx on public.messages(sender_id);
create index if not exists messages_receiver_id_idx on public.messages(receiver_id);

-- Drop Policies if they exist to prevent errors on re-run
DROP POLICY IF EXISTS "Users can view their own messages" ON public.messages;
DROP POLICY IF EXISTS "Users can insert their own messages" ON public.messages;


-- RLS Policies for Messages
-- 1. Enable RLS on the messages table
alter table public.messages enable row level security;

-- 2. Create policy for viewing messages
create policy "Users can view their own messages"
  on public.messages for select
  using ( auth.uid() = sender_id or auth.uid() = receiver_id );

-- 3. Create policy for inserting messages
create policy "Users can insert their own messages"
  on public.messages for insert
  with check ( auth.uid() = sender_id );


-- Function to get user's conversations for the inbox
create or replace function get_user_conversations(p_user_id uuid)
returns table (
    chat_id text,
    other_user_id uuid,
    other_user_name text,
    other_user_phone text,
    other_user_avatar text,
    last_message_content text,
    last_message_at timestamptz,
    unread_count bigint
)
as $$
begin
    return query
    with last_messages as (
        select
            m.chat_id,
            m.content,
            m.created_at,
            m.sender_id,
            m.receiver_id,
            -- Use ROW_NUMBER to find the latest message in each chat
            row_number() over(partition by m.chat_id order by m.created_at desc) as rn
        from
            messages m
        where
            m.sender_id = p_user_id or m.receiver_id = p_user_id
    )
    select
        lm.chat_id,
        -- Determine the other user's ID
        case
            when lm.sender_id = p_user_id then lm.receiver_id
            else lm.sender_id
        end as other_user_id,
        -- Fetch other user's name from either providers or customers table
        coalesce(prov.name, cust.name) as other_user_name,
        -- Fetch other user's phone from either providers or customers table
        coalesce(prov.phone, cust.phone) as other_user_phone,
        -- Fetch other user's avatar
        prov.profile_image->>'src' as other_user_avatar,
        lm.content as last_message_content,
        lm.created_at as last_message_at,
        0::bigint as unread_count -- Placeholder for unread count
    from
        last_messages lm
    -- Join to find the other user's details
    left join public.providers prov on prov.user_id = (case when lm.sender_id = p_user_id then lm.receiver_id else lm.sender_id end)
    left join public.customers cust on cust.user_id = (case when lm.sender_id = p_user_id then lm.receiver_id else lm.sender_id end)
    where
        lm.rn = 1 -- Only get the very last message for each chat
    order by
        lm.created_at desc;
end;
$$ language plpgsql security definer;


-- Grant execution rights for the function to authenticated users
grant execute on function public.get_user_conversations(uuid) to authenticated;
